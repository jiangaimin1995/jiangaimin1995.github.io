<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>临床预测模型|临床预测模型的开发、验证和更新等实践方法</title>
    <url>/year/02181194.html</url>
    <content><![CDATA[<p>在之前的很多篇推送中，我们探讨了很多关于临床预测模型的内容。接下来，我们将结合统计大神Ewout W. Steyerberg的著作—Clinical Prediction Models, A Practical Approach to Development, Validation, and Updating，对临床预测模型的理论和实践进行系统的学习。<br>在这次的内容中，我们将系统了解预测模型在医疗领域中的应用。</p>
<span id="more"></span>

<hr>
<h1 id="预测模型的应用有哪些？"><a href="#预测模型的应用有哪些？" class="headerlink" title="预测模型的应用有哪些？"></a>预测模型的应用有哪些？</h1><h2 id="医疗实践与研究"><a href="#医疗实践与研究" class="headerlink" title="医疗实践与研究"></a>医疗实践与研究</h2><p>在公共卫生领域，预测模型可能有助于针对患病或患病风险相对较高的受试者进行预防性干预。在临床实践中，预测模型可以告知患者及其治疗医生诊断的概率或预后结果。在诊断性检查中，预测可能有助于估计一种疾病存在的概率。在研究中，预测模型可能有助于设计干预研究。在随机试验的分析中，调整基线风险。在观察性的研究中，预测模型也有助于控制混杂变量。</p>
<h2 id="预测模型在公共卫生领域中的应用"><a href="#预测模型在公共卫生领域中的应用" class="headerlink" title="预测模型在公共卫生领域中的应用"></a>预测模型在公共卫生领域中的应用</h2><h3 id="增加预防性干预措施的针对性"><a href="#增加预防性干预措施的针对性" class="headerlink" title="增加预防性干预措施的针对性"></a>增加预防性干预措施的针对性</h3><p>预测模型可以预测人群中无症状受试者未来疾病的发生概率，例如众所周知的心血管疾病的弗雷明汉风险函数，其是当前多项预防性干预政策的基础。例如，他汀类药物治疗仅考虑用于心血管疾病风险相对较高的患者。同样，乳腺癌的预测模型也已开发出来，可以考虑对高风险人群进行更深入的筛查或化学预防。</p>
<h3 id="示例：乳腺癌预测模型"><a href="#示例：乳腺癌预测模型" class="headerlink" title="示例：乳腺癌预测模型"></a>示例：乳腺癌预测模型</h3><p>在1989年，Gail等人基于来自Breast Cancer Detection Demonstration Project（BCDDP）的病例对照数据，提出了著名的乳腺癌风险预测模型。BCDDP是美国国家癌症研究所（NCI）于1973年启动的一项大规模研究项目。该项目的目标是评估早期乳腺癌筛查的效果，以及使用乳房X线摄影术（即乳房X线照片，也称为乳房X光）进行早期乳腺癌筛查的可行性。<br>BCDDP的研究参与了约28万名女性，这些女性来自于30个不同的社区，并且在50岁至64岁之间。研究持续了6年，直到1979年。参与者被随机分配到两个组：一个接受乳房X线摄影术筛查的组，另一个是对照组，他们不接受筛查。这样设计是为了比较两组之间乳腺癌的发病率和死亡率。BCDDP的结果表明，接受乳房X线摄影术筛查的女性群体与未接受筛查的对照组相比，其乳腺癌的早期检测率有所增加，并且发现早期乳腺癌的女性死亡率较低。这些发现为乳腺癌筛查的推广提供了重要的科学证据，促进了早期诊断和治疗的实践。BCDDP为今后的乳腺癌筛查项目提供了基础，对于乳腺癌早期检测和治疗的重要性有着深远的影响。其他乳腺癌的风险预测模型还包括克劳斯模型（Claus Model）。Claus 模型以研究人员David J. D. Cunningham、Isaac D. Sasco、和Claus 和 Edward A. Cornwall 的名字命名。这个模型主要基于家族史，特别是家族中是否有一级亲属（母亲、姐妹或女儿）患有乳腺癌来预测个体患乳腺癌的风险。模型的基本假设是乳腺癌风险与家族史中患者的数量和关系的程度相关。一般来说，克劳斯模型根据患者家族中患有乳腺癌的亲属数量和患者年龄等因素，来估计患者未来发展乳腺癌的风险。具体而言，该模型可以根据家族史的情况将患者分为不同的风险组别，并给出相应的患病概率。与Gail模型不同，克劳斯模型需要输入一级或二级亲属乳腺癌确诊时的确切年龄。<br>一些乳腺癌是由乳腺癌易感基因（BRCA）突变引起的，称为遗传性乳腺癌。可疑的遗传性乳腺癌家族史包括许多乳腺癌和卵巢癌病例，或者家族成员中乳腺癌患者年龄在50岁以下。目前已经有简单的表格用于根据个人和家族史的特定特征来确定BRCA突变的风险。另一个模型更详细地考虑了家族史（BRCAPRO）。它明确使用家族中的遗传关系，因此被标记为孟德尔模型。计算基于贝叶斯定理。风险模型在乳腺癌中可能有两个主要作用：预测无症状女性的乳腺癌风险和预测BRCA基因突变的可能性。这些模型在预测因素方面有一些共同之处，当然也存在一些不同之处。有各种措施可以减少乳腺癌风险，包括行为干预（如锻炼、体重控制和饮酒）、预防性手术和医疗干预（如使用他莫昔芬）。</p>
<p><img src="https://pic4.zhimg.com/80/v2-07e06999d4c2b840d7b9bc768b25a7ff_1440w.webp" alt="四种乳腺癌预测模型的危险因素"></p>
<h2 id="预测模型在临床实践中的应用"><a href="#预测模型在临床实践中的应用" class="headerlink" title="预测模型在临床实践中的应用"></a>预测模型在临床实践中的应用</h2><h3 id="医疗决策支持"><a href="#医疗决策支持" class="headerlink" title="医疗决策支持"></a>医疗决策支持</h3><p>预测模型可能有助于估计潜在疾病的概率，以便我们进一步决策。当某种诊断的可能性极低时，通常无需进一步检查，而当诊断尚未充分确定以做出治疗决策时，可能需要进行更多检查。进一步的检查通常涉及一项或多项不完善的检查（灵敏度低于 100%，特异性低于 100%）。理想情况下，可以使用金标准检查（灵敏度 &#x3D; 100%，特异性 &#x3D; 100%）。然而在临床实践中，许多参考检查并不是真正的“金标准”，尽管它们被用作确定受试者是否患有该疾病的决定性指标。某些情况下，所谓的“金标准”可能不适合应用于所有怀疑患有该疾病的受试者，因为它可能对人体有害（例如侵入性检查）或者相当昂贵。</p>
<h3 id="示例：肾动脉狭窄的预测模型"><a href="#示例：肾动脉狭窄的预测模型" class="headerlink" title="示例：肾动脉狭窄的预测模型"></a>示例：肾动脉狭窄的预测模型</h3><p>肾动脉狭窄是高血压的罕见原因。肾动脉造影是诊断肾动脉狭窄的金标准，是一种侵入性且花费较高的诊断性操作。既往有研究基于患者的临床特征开发了肾动脉狭窄的预测模型，用于选择进行肾血管造影的患者。对 477 名接受肾血管造影的高血压患者的数据进行逻辑回归分析。选择年龄、性别、动脉粥样硬化性血管疾病、近期高血压发病、吸烟史、体重指数、腹部血管杂音、血清肌酐浓度和血清胆固醇水平作为预测因子。回归模型的诊断准确性与肾血管造影的性能相似，敏感度为 72%，特异度为 90%。作者基于以上模型开发了一个交互式的 Excel 程序用于估计每个患者的肾动脉狭窄概率。下图显示了一个45岁男性近期发病的高血压的例子。该患者吸烟，无动脉粥样硬化性血管疾病的迹象，BMI&lt;25，无腹部血管杂音，血清肌酐为112µmol&#x2F;L，血清胆固醇正常。计算其总得分为11分，对应于狭窄的概率为25%。根据精确的逻辑回归计算，该概率为28% [95%置信区间17-43%]。</p>
<p><img src="https://pic3.zhimg.com/80/v2-17daf9e226abdd9f93c10a03ded99bc2_1440w.webp" alt="肾动脉狭窄预测模型"></p>
<h3 id="确定干预阈值"><a href="#确定干预阈值" class="headerlink" title="确定干预阈值"></a>确定干预阈值</h3><p>决策分析是一种权衡决策利弊的方法。对于在诊断工作完成后开始治疗的情况，一个关键概念是治疗门槛。该门槛被定义为治疗的预期益处等于避免治疗的预期益处的概率。如果诊断的概率低于门槛值，则首选不推荐治疗；如果诊断的概率高于门槛值，那么推荐治疗。门槛值由假阴性与假阳性决策的相对权重确定。如果假阳性决策远不如假阴性决策重要，则门槛值较低。例如，对于过度治疗的风险为0.1%，而正确治疗的好处为10%，意味着接近1%的门槛值（比例为1:100，门槛概率为0.99%）。另一方面，如果假阳性决策会带来严重的风险，则门槛值应该更高。例如，与过度治疗相关的伤害为1%，则门槛值为9.1%（比例为1:10）。门槛概念的进一步细节将在决策曲线评估预测模型性能时进行讨论。</p>
<p><img src="https://pic1.zhimg.com/80/v2-29cb85cea9e56e798e715c6727c19484_1440w.webp" alt="在治疗决策时，当过度治疗的危害为0.1%（左上面板）或1%（右上面板）时，治疗阈值概念变得至关重要。如果有一个具有完美灵敏度和特异性的金标准，其固定的危害风险为0.1%，那么该指标表明患病概率在 0.9% 到 90% 之间（左下图）"></p>
<p>可以通过临床预测模型来估计疾病的概率。需要注意的是，只有当所有诊断检查（包括针对该疾病的所有可用检验）都完成时，才适用单一治疗阈值。如果仍然可以进行更多检验，则需要进行更复杂的决策分析以确定检查和治疗的最佳选择。然后我们有两个阈值：一个较低的阈值来识别那些没有接受治疗和没有接受进一步检查的患者；还有一个更高的阈值来确定谁将在没有进一步检查的情况下接受治疗。在这两者之间的是那些将受益于进一步检查的人。</p>
<h3 id="预测深静脉血栓"><a href="#预测深静脉血栓" class="headerlink" title="预测深静脉血栓"></a>预测深静脉血栓</h3><p>Wells临床预测规则结合了九个体征、症状和风险因素，将患者分为深静脉血栓（DVT）患病概率低、中等或高的类别。这个规则与单个特征相比可以更好地分层患者患有DVT的概率。对于低分险的患者（例如得分 ≤ 1），可以通过单独超声或血浆D-二聚体阴性结果排除DVT。对于DVT风险较高的患者（得分 &gt; 1）的患者则需要同时超声检查和D-二聚体检查阴性才能排除DVT风险，其具体工作算法如下：</p>
<p><img src="https://pic3.zhimg.com/80/v2-371c2f58bc005a183670b7748c276262_1440w.webp" alt="通过 D-二聚体检测和超声成像疑似 DVT 患者的可能诊断算法"></p>
<h3 id="评估治疗强度"><a href="#评估治疗强度" class="headerlink" title="评估治疗强度"></a>评估治疗强度</h3><p>预后估计在确诊后指导决策也很重要。决策包括更高或更低强度的治疗方法。基于预后的决策框架与之前讨论的基于诊断概率的框架非常相似。只有在预期获得实质性收益的情况下，才应给予患者治疗，这种收益应超过任何风险和副作用。这方面的一个经典案例是抗凝剂使用和心房颤动的风险的关系。抗凝剂在降低非风湿性心房颤动患者中风风险方面非常有效。然而，使用这些药物会增加严重出血的风险。因此，在考虑治疗之前，中风的风险必须超过出血的风险。这两种风险可能取决于预测因子。类似的分析已经用于急性心肌梗死患者溶栓治疗的适应症。</p>
<h3 id="示例：定义一个癌症预后不良的亚组"><a href="#示例：定义一个癌症预后不良的亚组" class="headerlink" title="示例：定义一个癌症预后不良的亚组"></a>示例：定义一个癌症预后不良的亚组</h3><p>我们将高剂量化疗（HD-CT）作为一线治疗，以提高非精原细胞性睾丸癌患者的生存率。一些非随机试验报道，与标准剂量（SD）化疗（包括博莱霉素、依托泊苷和顺铂）相比，接受自体干细胞支持的一线治疗（包括依托泊苷、异环磷酰胺和顺铂）的患者生存率更高。然而，HD-CT与治疗期间（如粒细胞减少、贫血、恶心&#x2F;呕吐和腹泻）、治疗后短期（如肺毒性）和治疗后长期（如白血病和心血管疾病）更严重的毒性发生相关。因此，HD-CT只适用于预后相对较差的患者。我们可以通过权衡预期的益处与危害来确定这种预后不良群体的阈值。HD-CT治疗的益处在于降低癌症死亡的绝对风险。如果我们假设处于最高风险的患者获益最大，那么益处随着癌症死亡风险呈线性增加。危害是由于治疗而导致治疗死亡的绝对风险增加（例如，与毒性相关）。假设治疗的毒性与预后无关，那么所有患者的危害水平相同。当患者的癌症死亡风险高于阈值时，即益处大于危害时，此时应该给予患者更为积极的治疗。</p>
<p><img src="https://pic1.zhimg.com/80/v2-5468faa39308624ee5d5a6f49920f908_1440w.webp" alt="权衡治疗利弊的示意图。治疗的益处（降低绝对风险）随着癌症特异性死亡率的增加而增加（相对风险设置为0.7）。治疗的危害（额外的绝对风险，例如，由于治疗的毒性）被假定为固定在4%。只有当给予标准治疗的癌症特异性死亡率超过11% 的阈值时，才会出现净效益。   "></p>
<h3 id="治疗的成本效益"><a href="#治疗的成本效益" class="headerlink" title="治疗的成本效益"></a>治疗的成本效益</h3><p>治疗的成本效益直接取决于预后。如果收益很小（对于低风险的患者）和成本很高（例如，对所有患者产生相同的药物成本），那么治疗可能不具有成本效益。例如，他汀类药物治疗只适用于心血管风险增加的患者。而更积极的溶栓治疗只应用于那些有30天死亡风险增加的急性心肌梗死患者。可以发现许多其他的例子，假设治疗的相对益处在不同的风险群体中是恒定的，因此绝对收益随着风险的增加而增加。在上图中，我们假设伤害恒定，而获益与死亡风险相关。后者同时依赖于有效的预后模型与单一治疗的相对治疗效果。可以考虑对这种方法进行扩展，如果对更大的数据集进行建模，则具有更高的可靠性。具体来说，我们在患者亚组中寻找不同的治疗效果。然后放宽相对获益固定的假设：一些患者可能对某种治疗反应相对较好，而另一些则没有。年龄或特定疾病类型等患者特征可能与治疗反应相互作用。药物的作用可能被药物代谢影响，例如，由细胞色素 P450酶和药物转运蛋白介导。药物基因组学领域的研究人员旨在进一步了解个体患者的基因构成（基因型）与药物治疗反应之间的关系，以便更好地预测治疗反应。成本效益将根据治疗反应的不同可能性而有所不同。但应该注意的是，在没有生物学机制&#x2F;原理的情况下，这种亚组效应很可能是虚假的。即使存在生物学机制&#x2F;原理，也需要足够大的样本量来保证亚组分析的统计效能。这些远远超过了检测治疗的主效应所需的样本量。在最佳情况下，样本大小需要是四倍大才能检测到与主效应相同大小的交互作用。如果我们假设交互作用是主效应大小的一半，则需要16倍的样本量。 </p>
<h3 id="延迟治疗"><a href="#延迟治疗" class="headerlink" title="延迟治疗"></a>延迟治疗</h3><p>在医疗实践中，预测模型可以为患者及其亲属提供信息，使他们对病程有现实的预期。有时可以采取保守的方法，即遵循疾病的自然史。例如，如果检测到“惰性”的前列腺癌，许多男性可能会选择观察等待策略。或者，如果女性具有相对有利的特征，她们可能会对怀孕机会感到放心。</p>
<h3 id="示例：自然怀孕的机会"><a href="#示例：自然怀孕的机会" class="headerlink" title="示例：自然怀孕的机会"></a>示例：自然怀孕的机会</h3><p>根据三项预测不育夫妇自然妊娠的模型研究的数据，开发了一种“综合模型”，用于预测在随访1年内活产的自发受孕。这种综合模型比原始模型具有更广泛的经验基础。预测因素包括一些容易获得的特征，例如不孕持续时间、女性年龄、原发性或继发性不孕症、活动性精子的百分比，以及这对夫妇是由全科医生还是妇科医生转诊。使用该模型，可以很便捷地计算出一年内自然怀孕的概率。（首先计算预后分数。然后，预后分数对应于一个概率，可以从图表中读取）。</p>
<p><img src="https://pic2.zhimg.com/80/v2-a97d74e116eed3b930720c639729b8c1_1440w.webp" alt="用于估计摄入后 1 年内自然怀孕并活产的评分表。上半部分：计算分数；下半部分：预测1年妊娠率。"></p>
<h3 id="手术决策"><a href="#手术决策" class="headerlink" title="手术决策"></a>手术决策</h3><p>在手术中，通常会采取短期风险来降低长期风险。短期风险包括并发症和死亡率。手术旨在减少自然病程中可能发生的长期风险。紧急情况下的手术包括创伤手术和动脉瘤破裂（动脉扩张）等疾病相关的手术。择期手术针对许多情况进行，即使对于这样有计划和准备充分的手术，短期风险和负担也绝不会为零。在肿瘤学中，手术风险增加通常会导致选择风险较低的治疗，例如化疗或放疗，或姑息治疗。例如，在许多癌症中，老年患者和合并症较多的患者较少接受手术。目前已经开发了许多预后模型来估计手术的短期风险，例如30天死亡率。这些模型的复杂性和准确性各不相同。此外，尽管很难找到不需要手术干预治疗适合疾病自然病程的患者群体，仍然有一些针对各种疾病长期风险的模型被开发。</p>
<h3 id="示例：有风险的心脏瓣膜置换的手术决策问题"><a href="#示例：有风险的心脏瓣膜置换的手术决策问题" class="headerlink" title="示例：有风险的心脏瓣膜置换的手术决策问题"></a>示例：有风险的心脏瓣膜置换的手术决策问题</h3><p>Björk–Shiley convexo-concave (BScc) 机械心脏瓣膜在报告机械故障（出口支柱断裂）后于1986年退出市场。截至该产品退出市场时，全世界已经植入了大约86,000个BScc瓣膜。出口支柱突然断裂通常是致命的。因此，可以考虑用另一个更安全的瓣膜进行预防性置换，以避免断裂的风险。而决策分析是衡量因出口支柱断裂导致的长期预期寿命减少与短期手术死亡风险非常有用的方法。<br>出口支柱断裂风险导致的长期预期寿命损失取决于三个方面：（1）患者存活情况下，每年发生断裂的风险；（2）断裂的致死率；（3）年死亡风险（生存）。这种预期寿命的长期减少必须与手术死亡的风险进行权衡。<br>如果患者在手术中幸存下来，则假定断裂风险降至零。根据1979年至1985年间荷兰2,263名植入BScc瓣膜的患者的随访经验，考虑了随访期间发生的50例断裂和883例死亡患者（不包括断裂）。针对各个方面开发了预测回归模型。断裂风险是这个决策问题的关键因素。出现结局事件的患者样本量较少使得预测建模具有挑战性，预测模型的各个变量也需要关注。一个相对详细的模型包括四个传统预测因素，年龄、位置（主动脉&#x2F;二尖瓣）、瓣膜类型（70°开角瓣膜的风险高于 60°瓣膜）和尺寸（瓣膜越大风险越高），以及两个生产特征。断裂的死亡率取决于患者的年龄和位置（主动脉位置的瓣膜死亡率更高）。存活率与年龄、性别、瓣膜位置和植入后时间有关。手术风险根据年龄和瓣膜位置进行建模。该决策分析的结果很大程度上取决于年龄：只有对于年轻患者才建议进行置换手术，因为他们手术风险较低，并且由于存活时间较长，骨折的长期影响更大。此外，瓣膜的位置会影响所有四个结局（手术风险、生存、断裂和死亡）。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c24a579cf10fa730b7ebf9abe3098a8d_1440w.webp" alt="有风险心脏瓣膜置换的短期与长期风险的手术决策示意图。正方形表示一个决策，圆圈代表一个机会节点。需要对四种概率进行预测：手术死亡率、长期生存率、瓣膜破裂和瓣膜断裂死亡率。"></p>
<p><img src="https://pic3.zhimg.com/80/v2-70f1b4a17486bb7cb2ec77edb0c8b03e_1440w.webp" alt="替换风险性心脏瓣膜决策分析的患者特征"></p>
<h2 id="预测模型在医学研究中的应用"><a href="#预测模型在医学研究中的应用" class="headerlink" title="预测模型在医学研究中的应用"></a>预测模型在医学研究中的应用</h2><p>在医学研究中，预测模型有以下用途。在实验研究中，比如随机对照试验，预后基线特征可能有助于患者的纳入和分层，并改善统计分析。在观察性研究中，充分控制混杂因素是至关重要的。</p>
<h3 id="随机对照试验中的纳入和分层"><a href="#随机对照试验中的纳入和分层" class="headerlink" title="随机对照试验中的纳入和分层"></a>随机对照试验中的纳入和分层</h3><p>在随机临床试验（RCTs）中，预后估计可用于选择研究对象。传统上，一组包含和排除标准被应用于定义RCT的研究对象。这些标准旨在根据预期结果创建更同质的群体。患者必须满足所有纳入标准，而非排除标准。或者，一些预后标准可以结合在预测模型中，根据个性化的预测进行选择。这会导致更精细的选择。在RCTs中，通常建议对主要预后因素进行分层。通过这种方式，试验组之间基线的预后得以被平衡。这有助于治疗结果的简单、直接比较，特别是对于较小的RCTs，可能更加容易出现一些基线不平衡。预后模型可以细化患者的这种分层，特别是当许多预后因素是已知的情况下。</p>
<h3 id="示例：创伤性脑损伤的病例选择"><a href="#示例：创伤性脑损伤的病例选择" class="headerlink" title="示例：创伤性脑损伤的病例选择"></a>示例：创伤性脑损伤的病例选择</h3><p>依据创伤性脑损伤的两个预测因子进行预后选择,在选择创伤性脑损伤 (TBI) 患者进行随机对照试验时。65 岁以上的患者和瞳孔无反应的患者常因预后很差而通常被排除在外。现实情况中，我们发现满足任一上述标准的患者在 6 个月的随访中死亡率高于 50%。因此，我们可以简单地只选择那些 65 岁以下且至少有一侧瞳孔反应的患者。</p>
<p><img src="https://pic1.zhimg.com/80/v2-72db249a5faddfb404cb97e4b72dcfec_1440w.webp" alt="根据瞳孔对光反射和年龄，对7143例重度或中度创伤性脑损伤患者的预后进行分析"></p>
<p>我们还可以基于单个指标使用预后模型来更有效地选择患者纳入研究。一个简单的回归模型中可以用“年龄”和“瞳孔反应”更详细地计算死亡概率。如果我们的目标是排除那些预测风险超过50%的患者，这将导致无任何瞳孔反应的患者的年龄限制为30岁，而有任何瞳孔反应的患者的年龄限制为76岁。因此，如果我们只想纳入那些死亡风险 &lt;50% 的患者，则始终可以纳入30 岁以下的患者，并且如果至少有一侧瞳孔存在对光反射，则可以纳入65 至 75 岁之间的患者 。</p>
<p><img src="https://pic3.zhimg.com/80/v2-5094ad9999640332183a56f1d09b3a5e_1440w.webp" alt="以传统方式 (A) 和根据预后模型（6 个月死亡率 &lt; 50% 的概率，B）选择符合 2 个标准（年龄和瞳孔对光反射）的患者"></p>
<h3 id="RCT中的协变量调整"><a href="#RCT中的协变量调整" class="headerlink" title="RCT中的协变量调整"></a>RCT中的协变量调整</h3><p>预测模型更重要的作用是在RCT分析中的预后基线特征的作用。随机化的优势在于，在观察到的和未观察到的基线特征方面，在治疗组之间产生了可比性。因此，在RCT中不会出现系统的混杂因素。但是一些观察到的基线特征可能与结局密切相关。对这种协变量进行调整有几个优点：<br>&#x3D;&#x3D;减少组间随机不平衡造成的治疗效果估计中的任何失真&#x3D;&#x3D;<br>&#x3D;&#x3D;增加检测治疗效果的统计效能&#x3D;&#x3D;</p>
<p><img src="https://pic2.zhimg.com/80/v2-53465a85261ac786bb44864d4aab9209_1440w.webp" alt="随机对照试验中基线特征的作用示意图。通过随机化，基线特征、观察到或未观察到的特征与治疗之间没有系统的联系。基线特征仍然很重要，因为它们通常是预后的预测因素。"></p>
<p><img src="https://pic1.zhimg.com/80/v2-e212cb128dd98372910e0bce44d3be04_1440w.webp" alt="当预测因子完全平衡时，在线性和广义线性模型（如逻辑回归）的估计和检验中对预测因子的调整进行比较
值得注意的是，协变量调整对于线性回归模型和广义线性模型（例如逻辑回归、Cox 回归）的作用不同。"></p>
<p>对于随机临床试验，随机化保证估计治疗效果的偏倚先验为零，不会因观察到或未观察到的基线特征而失真。然而，可能会出现随机不平衡，产生这样的问题：如果两组完全平衡，治疗效果会怎样？我们可能认为这种扭曲是一种后验偏移，因为它影响解释的方式与观察流行病学研究类似。<br>回归分析可以纠正这种随机不平衡。当回归模型中考虑的预测变量没有发生不平衡时，调整后和未调整的治疗效果估计值预计将相同。线性回归分析中确实如此。值得注意的是，在逻辑回归等广义线性模型中，即使预测变量完全平衡，调整后和未调整的治疗效果估计值也不同。调整后的效果预计将进一步远离零（中性值，OR进一步远离1）。这种现象被称为效应估计的“不可折叠性”，或“分层效应”。线性回归不会发生这种情况。<br>通过线性回归，对重要预测变量的调整可以提高估计治疗效果的准确性，因为结局的部分方差是由预测变量解释的。相反，在逻辑回归等广义线性模型中，治疗效果的标准误差总是随着调整而增加。在线性回归中，调整分析为治疗效果分析提供了更多依据，因为治疗效果的标准误差更小。对于逻辑回归等广义线性模型，调整对效能的影响并不明确。然而，已证明治疗效果估计的预期值增加超过标准误差。因此，与未调整的分析相比，调整后的逻辑回归分析中检测治疗效果的效能更高，类似于线性回归模型。    </p>
<h3 id="通过协变量调整来增加效能"><a href="#通过协变量调整来增加效能" class="headerlink" title="通过协变量调整来增加效能"></a>通过协变量调整来增加效能</h3><p>协变量调整导致的效能增加取决于基线协变量（预测因子）和结局之间的相关性。对于连续性结局，这种相关性可以用Pearson相关系数(r)来表示。样本量可以减少 1−r2，以通过协变量调整分析获得与未调整分析相同的统计效能 。非常强的预测变量可能具有 r &#x3D; 0.7 (r2 &#x3D;50%)，例如血压等重复测量的基线协变量或问卷分数。所需的患者数量大约减少一半。r &#x3D; 0.3 时节省不到 10% (r2&#x3D; 9%)。在二分类结局的实证评估中也得到了类似的结果，其中Nagelkerke’s R2被用来表示预测因子和结局之间的相关性。在急性心肌梗死患者和脑外伤患者的死亡率模拟中，样本量的减少略小于1-R2。</p>
<p><img src="https://pic4.zhimg.com/80/v2-3f6d5c1c7b4338ec9bd95a7938cdaf2f_1440w.webp"></p>
<h3 id="示例：GUSTO-III-试验分析"><a href="#示例：GUSTO-III-试验分析" class="headerlink" title="示例：GUSTO-III 试验分析"></a>示例：GUSTO-III 试验分析</h3><p>GUSTO-III试验主要纳入急性心肌梗死患者。主要结局是30天死亡率。该试验预先指定了一个预后模型对干预效果进行初步分析。该模型结合了年龄、收缩压、Killip分级、心率、梗死位置和年龄与Killip分级的交互作用。在之前的GUSTO-I 试验中发现这些预测因子包含了30 天死亡率模型的 90% 的预后信息。如上所述，有相当多的理由可以更广泛地使用这种协变量调整。    </p>
<h3 id="观察性研究中的预测模型"><a href="#观察性研究中的预测模型" class="headerlink" title="观察性研究中的预测模型"></a>观察性研究中的预测模型</h3><p>观察性研究的主要目的是估计因果效应。混杂因素是观察性研究的流行病学分析中主要关注的问题。当比较治疗时，由于缺乏随机化，各组之间的基线信息通常参差不齐。具有特定特征的受试者比其他受试者更有可能接受某种治疗（“指示混淆”）。如果这些特征也影响结局，则治疗效果的直接比较是有偏移的，并且可能仅仅反映缺乏基线可比性（“混杂”）。除了治疗之外，还可以研究其他因素的病因学影响。通常来说，当随机化不可能时，若观察性研究是唯一可行的设计。处理混杂因素是此类分析中的一个重要步骤。回归分析是控制治疗组之间基线不平衡的常用方法，例如逻辑回归或 Cox 回归 。许多基线特征可以同时调整。与随机对照试验相反，我们只能平衡观察到的基线特征，理想情况下没有测量误差。我们应该特别担心任何未知的协变量，这些协变量可能会因与治疗选择和结局的关联而成为混杂因素。</p>
<p><img src="https://pic3.zhimg.com/80/v2-79663837385415dc5412e707d766a8a6_1440w.webp" alt="观察性研究中基线特征调整的示意图。通过调整，我们的目标是纠正观察到的基线特征和结局之间的系统联系，从而回答以下问题：如果治疗组之间观察到的基线特征相似，治疗效果如何？"></p>
<h3 id="倾向性评分"><a href="#倾向性评分" class="headerlink" title="倾向性评分"></a>倾向性评分</h3><p>当结局相对罕见时，用回归分析进行调整就会出现问题。这可能会导致调整分析中组间差异的估计存在偏差且效率低下。另一种方法是使用倾向评分，这在上面的情况中特别适用。倾向性评分定义了在给定一组混杂因素的情况下受试者接受特定治疗（“Tx”）的概率：p(Tx | 混杂因素)。为了计算倾向性评分，通常在逻辑回归模型中使用混杂因素来预测治疗，而不包括治疗结局。随后，倾向性得分在第二阶段用作汇总混杂因素。第二阶段的常见方法是倾向性评分匹配、倾向性评分分层（通常按四分位数）以及将倾向性评分与治疗纳入结局回归模型中。实证比较表明倾向性评分方法并没有优于传统的回归分析。相比之下，模拟研究表明，相对于混杂因素的数量，在结局很少的情况下，倾向性得分对于研究有一定益处。</p>
<p><img src="https://pic2.zhimg.com/80/v2-0506e83b4fc5578edae25d2653020861_1440w.webp" alt="观察性研究中基线特征的倾向性评分调整的示意图。"></p>
<h3 id="示例：他汀类药物治疗效果"><a href="#示例：他汀类药物治疗效果" class="headerlink" title="示例：他汀类药物治疗效果"></a>示例：他汀类药物治疗效果</h3><p>他汀类药物对急性心肌梗死（AMI）发生的影响已在随机对照试验和观察性研究中进行了研究。对1994年至1998年期间任何时候记录的LDL&gt;为130mg&#x2F;dl的社区健康计划成员进行倾向性评分分析。使用倾向性得分匹配开始使用他汀类药物治疗的患者和未开始他汀类药物治疗的患者。倾向评分预测了开始使用他汀类药物的概率。采用包含52个变量和6个二次项的logistic回归模型估计得分。开始使用他汀类药物患者与具有相似接受治疗倾向的未开始使用他汀类药物患者匹配（倾向误差在 0.01 以内）。找不到合适的匹配对象的患者将会被排除。在 4144 个使用他汀类药物患者中留下了 2901 个（70%）。4144 名患者的已知冠心病危险因素的患病率高于不匹配的未开始使用他汀类药物的患者。对这些未匹配队列的随访发现，启动他汀类药物治疗的患者中有325例AMI，未启动的患者中有124例AMI（风险比 2.1）。倾向性得分匹配队列 (n &#x3D; 2901) 在 52 个匹配基线特征中有51个特征非常相似。开始使用他汀类药的患者中有 77 例 AMI，而匹配的未开始他汀治疗的患者中有 114 例发生 AMI（风险比 0.69）。作者得出的结论是，该社区健康计划的成员使用他汀类药物有利于 AMI 的发生，但需要警示的是，不属于模型部分的预测因子可能在倾向性评分匹配的队列之间保持不平衡，从而导致残余混杂。</p>
<p><img src="https://pic1.zhimg.com/80/v2-c8819c11d119c40088428f0089960c44_1440w.webp" alt="他汀类药物对急性心肌梗死发生的影响"></p>
<h3 id="不同数据来源的比较"><a href="#不同数据来源的比较" class="headerlink" title="不同数据来源的比较"></a>不同数据来源的比较</h3><p>预测模型的另一个应用领域是比较不同医院（或其他护理提供者）的结局。医疗保健提供者的质量是根据其结局进行比较的，这些结局被视为绩效指标。提供者之间的简单比较显然可能会因病例组合的差异而产生偏移，例如，学术中心可能会看到更严重的患者，这导致患者整体结局较差。在这种比较中需要预测模型来进行案例组合调整。另一个问题是提供的单位可能较小并且进行了多次比较。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，预测模型的潜在应用领域，包括公共卫生（预防干预的目标）、临床实践（诊断检查、治疗决策、共同决策）和医疗研究（随机对照试验的设计和分析） ，观察性研究中的混杂因素调整）。从模型中获取预测必须与深入了解疾病机制和病理生理过程分开。 </p>
<hr>
<h1 id="预测模型的研究设计相关问题"><a href="#预测模型的研究设计相关问题" class="headerlink" title="预测模型的研究设计相关问题"></a>预测模型的研究设计相关问题</h1><p>在本章中，我们主要学习预测研究设计中的几个问题，包括选择队列研究所需要的受试者或患者以及来自单一中心、来自注册登记或随机对照试验的病例的优势和局限性；预测模型中选择预测因子和结局变量的问题；此外，还有一个重要的问题是研究需要多大规模（样本量）才能支撑足够的统计学检验效能。</p>
<h2 id="预后研究"><a href="#预后研究" class="headerlink" title="预后研究"></a><strong>预后研究</strong></h2><p>预后研究本质上是纵向研究，最常在患者队列中进行，随着时间的推移对患者进行随访以观察结局（或“事件”或“终点”）的发生。这个队列的定义是基于一个或多个特定的特征，比如患有某种疾病、居住在特定地方、年龄在一定范围内，或者仅仅是活产。几种队列研究类型可以用于预后模型的开发，最常见的可能是单中心回顾性队列研究。例如，识别医院病历记录中特定日期范围之间的患者，并对这些患者的病历资料向前追溯。</p>
<p><img src="https://pic1.zhimg.com/80/v2-a22f5b91137bd111d5617820de609eb0_1440w.webp" alt="针对预后研究的研究设计"></p>
<h3 id="回顾性设计"><a href="#回顾性设计" class="headerlink" title="回顾性设计"></a><strong>回顾性设计</strong></h3><p>回顾性研究设计的优点包括其简单性和可行性。由于在单个中心的病人记录通常可以轻松地搜索，特别是在现代医院信息系统或电子病历的帮助下，因此它是一个相对成本较低的设计。一个局限性是正确识别病人，这必须在事后完成。如果某些信息缺失或记录不正确，这可能导致选择性偏倚。同样，预测因子的记录必须是可靠的，才能用于预测建模。最后，结果评估必须是可靠的。对于硬性终点如存活情况来说，这可能相对简单，因为一些死亡情况将从医院记录中知晓。但是，为了完整评估存活状况，通常还需要从全国统计局获得额外的生存状态确认。其他结果，例如与功能状态相关的结果，在我们希望进行分析的时间点可能不可用。最后，单中心研究可能受到样本量的限制，这是预测研究中的一个关键问题。</p>
<h3 id="示例：预测食管癌的早期死亡率"><a href="#示例：预测食管癌的早期死亡率" class="headerlink" title="示例：预测食管癌的早期死亡率"></a><strong>示例：预测食管癌的早期死亡率</strong></h3><p>对 1997 年 1 月 1 日至 2003 年 12 月 31 日期间在同一机构接受治疗的 120 名患者进行了回顾性分析。患者接受姑息治疗，这意味着治疗可以缓解症状，但不会改变病程。患者由于吞咽困难植入了食管支架。作者研究了 30 天死亡率，大概出现在约 10%（n &#x3D; 12）的患者中。预测因素是营养状况（低血清白蛋白水平、低BMI）和体能状态（WHO 等级）。</p>
<h3 id="前瞻性设计"><a href="#前瞻性设计" class="headerlink" title="前瞻性设计"></a><strong>前瞻性设计</strong></h3><p>在前瞻性研究中，我们可以更好地设定纳入和排除标准。研究者与研究人群一起随着时间推移（因此被称为“前瞻性研究”）。在前瞻性研究中，我们可以使用清晰一致的预测因子，并在预定义的时间点评估患者预后。因此，前瞻性队列研究优于回顾性系列研究。纯粹用于预测模型的前瞻性队列研究很少见。更常见的设计是将预测研究应用于随机临床试验 (RCT) 的数据，或前瞻性前后试验的数据。优点在于患者选择明确，预测因子记录前瞻性，通常会进行质量控制，并且对终点进行前瞻性评估。临床试验的样本量通常相当大。然而，来自 (随机) 试验数据的限制可能在于患者的选择。临床试验通常会使用严格的纳入和排除标准，这可能会限制由此开发的模型的普遍性。另一方面，RCT 通常会在多个中心进行，有时来自多个国家或地区。多中心设计的优势在于，需要就预测因子和结局的定义问题达成共识，并且会提高研究结果的可推广性。这与单中心研究形成对比，后者仅反映特定环境中的关联。一个争论的话题是，我们是否应该只使用来自随机分配到常规治疗或安慰剂（“对照组”）的 RCT 患者。如果我们结合随机分组，我们假设没有特定的亚组效应与预后模型相关。这通常可能是合理的。治疗的预后影响通常比其他预测因子的预后影响小。如果预测模型旨在支持治疗决策，最简单且相当合理的方法是将治疗作为主要效应纳入。</p>
<h3 id="示例：预测食管癌的长期死亡率"><a href="#示例：预测食管癌的长期死亡率" class="headerlink" title="示例：预测食管癌的长期死亡率"></a><strong>示例：预测食管癌的长期死亡率</strong></h3><p>在另一项食管癌结局研究中，来自 RCT（“SIREC”，n &#x3D; 209 ）的数据与其他前瞻性收集的数据（n &#x3D; 396） 相结合。研究者研究了支架置入和放疗姑息治疗后的长期死亡率。作者结合了年龄、性别、肿瘤长度、转移和 WHO 表现评分，提出了一个简单的预后评分。</p>
<h3 id="注册登记研究的设计"><a href="#注册登记研究的设计" class="headerlink" title="注册登记研究的设计"></a><strong>注册登记研究的设计</strong></h3><p>预测性研究通常利用登记数据进行，例如癌症登记数据或保险数据库。这些数据的收集虽然是前瞻性的，但最初目的并非用于预测研究。数据细节的不足可能限制了预测性分析。例如，美国著名的癌症登记系统 (Surveillance, Epidemiology and End Results, SEER) 包含癌症发病率、死亡率、患者人口统计学特征和肿瘤分期等信息。它已与 Medicare 数据库链接，以获取关于合并症和治疗 (手术、化疗、放射治疗) 的信息。社会经济地位通常基于可用区域的中位收入，属于汇总数据。SEER-Medicare 数据库不包含详细的PS信息，而这对于医疗决策和生存期评估至关重要。此外，SEER数据库中的肿瘤分期可能存在一些测量偏差。由于通常没有提前确定的评估，与回顾性研究类似，基于登记数据的预测性分析存在着同样的限制。因此，研究结局通常仅限于生存率，尽管有时也可以从中推导出其他不良事件。利用登记数据进行预测性研究的优势包括样本量大、患者具有代表性 (尤其是基于人群的癌症登记)。大型数据库可用性高，尤其适用于研究少数预测因素与生存期之间的预测关系。</p>
<h3 id="食管癌的手术死亡率"><a href="#食管癌的手术死亡率" class="headerlink" title="食管癌的手术死亡率"></a><strong>食管癌的手术死亡率</strong></h3><p>研究者使用SEER-Medicare数据库分析了1327例食管癌手术患者的30天死亡率。预测因子包括年龄、合并基础疾病（心脏、肺、肾、肝和糖尿病）、术前放疗或联合放化疗，以及相对较低的医院容量。研究者将上述因素合并为一个简单的预后评分，在另一个登记处和一个医院系列中完成了模型的验证。</p>
<h3 id="巢式病例对照研究"><a href="#巢式病例对照研究" class="headerlink" title="巢式病例对照研究"></a><strong>巢式病例对照研究</strong></h3><p>有时候，前瞻性设计的巢式病例-对照研究是进行预测研究的高效选择。当研究结局相对罕见时，病例-对照设计尤其具有吸引力，例如乳腺癌的发病率。例如，如果30天死亡率为1%，那么只需要研究所有死亡患者的预测因素就足够了，而对照组只需要研究4%的人（1:4的病例-对照比例）。选择随机选取的对照组与病例进行比较。然而，在巢式病例对照研究中，评估预测因素是回顾性的，这是该研究方法的一个局限性。如果开发了一个预测模型，则必须在最终计算概率时调整平均结局的发生率，而回归系数可能基于病例-对照研究。</p>
<h3 id="示例：大血管手术的围术期死亡率"><a href="#示例：大血管手术的围术期死亡率" class="headerlink" title="示例：大血管手术的围术期死亡率"></a><strong>示例：大血管手术的围术期死亡率</strong></h3><p>一个有趣的例子是分析接受大血管手术患者围手术期死亡率的研究。研究人员通过详细回顾所有病例（死亡患者）和部分对照组（存活患者）的病历资料，确定了预测因素。对照组患者的手术时间紧靠病例组之前或之后，从而实现了病例与对照组的 1:2配比。</p>
<h2 id="诊断研究"><a href="#诊断研究" class="headerlink" title="诊断研究"></a><strong>诊断研究</strong></h2><p>诊断研究最常采用横断面研究设计，将患者的预测性特征与潜在诊断联系起来。研究组依据特定症状或体征定义，这些症状或体征使受试者疑似患有特定(目标)疾病。通常，受试者将在短时间内接受相关测试，以确定是否存在目标疾病。</p>
<h3 id="横断面研究设计和多变量建模"><a href="#横断面研究设计和多变量建模" class="headerlink" title="横断面研究设计和多变量建模"></a><strong>横断面研究设计和多变量建模</strong></h3><p>理想情况下，诊断研究应考虑一组定义明确的疑似患有特定疾病的患者，例如急性心肌梗死。此时，该诊断研究类似于预后队列研究。队列由被怀疑患有 (而非实际患有) 疾病的患者定义。研究结局是潜在的诊断。因此，这样的研究可以被认为为是横断面研究，因为预测因果-结局关系是在一个时间点上进行研究的。几种特征可能预示潜在的诊断。对于模型，我们应该首先考虑简单的特征，例如人口统计学特征、从患者病史中获得的症状和体征。接下来，我们可能会考虑简单的诊断测试，最后是侵入性或昂贵的检查。诊断 (存在或不存在目标疾病) 应通过金标准来明确诊断。金标准检测的结果最好在不了解预测变量和诊断测试值的情况下进行解释。这样的盲法可以防止信息偏倚或纳入偏倚。诊断评估中常见的一个问题是所有预测特征的注册不完整。此外，并非所有患者都可能完成所有诊断检查，尤其是当他们被认为患目标疾病的风险较低时。此外，如果所使用的测试作为金标准而被选择性地进行，则可能导致结局评估不完整。这些问题在常规实践数据进行的诊断分析中尤为突出。因此，这种情况下前瞻性研究将更有用武之地，因为它们可以采用预先制定的方案进行系统诊断检查和金标准测试。</p>
<h3 id="示例：肾动脉狭窄的诊断"><a href="#示例：肾动脉狭窄的诊断" class="headerlink" title="示例：肾动脉狭窄的诊断"></a><strong>示例：肾动脉狭窄的诊断</strong></h3><p>研究者回顾性分析了接受腹主动脉造影检测隐匿性肾动脉狭窄的患者的心脏病学数据库。在开发队列中，635例患者中有128例观察到狭窄。如果患者因怀疑狭窄而接受血管造影，这20%的患病率可能被高估了。</p>
<h3 id="病例对照研究"><a href="#病例对照研究" class="headerlink" title="病例对照研究"></a><strong>病例对照研究</strong></h3><p>诊断研究有时会根据参考测试确定的目标疾病是否存在来选择患者，而参考测试则按照常规治疗进行。因此，没有参考标准的患者不会被选择。事实上，这相当于进行了病例-对照研究，其中病例是患有目标疾病的人，对照是未患病的人。这种设计存在一些局限性，特别是与所选患者对所有疑似患病患者的代表性相关。这与嵌套病例-对照研究不同。选择偏倚是另一个重要的限制。事实上，现在已经有了关于诊断研究中可能出现的偏倚的实证证据，特别是当病例-对照设计中包含非连续性患者、非代表性患者（严重病例与健康对照组相比）以及数据是回顾性收集的时候。</p>
<h3 id="诊断急性阑尾炎"><a href="#诊断急性阑尾炎" class="headerlink" title="诊断急性阑尾炎"></a><strong>诊断急性阑尾炎</strong></h3><p>C反应蛋白 (CRP) 常用于辅助诊断急性阑尾炎。对于 CRP 较高的患者，手术和病理结果作为参考标准。而 CRP 较低的患者通常不会立即手术，而是通过临床随访观察病情发展，再决定是否为阑尾炎。由于 CRP 水平升高不一定是由阑尾炎引起，轻微感染也可能导致 CRP 升高，但这类感染本身可能自行消退。因此，仅通过随访判断 CRP 较低患者是否为阑尾炎可能会漏掉一些真实患病者，导致 CRP 的诊断准确性被高估。</p>
<h2 id="预测因子与结局"><a href="#预测因子与结局" class="headerlink" title="预测因子与结局"></a><strong>预测因子与结局</strong></h2><h3 id="预测因子的强度"><a href="#预测因子的强度" class="headerlink" title="预测因子的强度"></a><strong>预测因子的强度</strong></h3><p>一个表现良好的预测模型必须包含强有力的预测因子。预测因子的强度取决于其与结局的关联程度（“效应大小”），以及预测因子的分布。例如，对于一个OR值为2.0二分类预测因子，当该预测因子的分布比例为50:50（预测因子的患病率为50%）时，与分布比例为1:99（预测因子的患病率为1%）且OR值为2.5的二分类变量相比，前者与预测模型更加相关。类似地，连续性预测因子必须涵盖广泛的范围才能对预测起到重要作用。</p>
<p>当某些特征被视为关键预测因子时，必须仔细记录这些特征，具有清晰的定义，最好没有缺失值。这通常在前瞻性研究中最为可行。</p>
<h3 id="预测变量的类别"><a href="#预测变量的类别" class="headerlink" title="预测变量的类别"></a><strong>预测变量的类别</strong></h3><p>预测模型的几类预测变量：</p>
<p>• 人口统计学数据（例如，年龄、性别、种族、教育程度、社会经济地位）；</p>
<p>• 疾病的类型和严重程度（例如，主要诊断、表现特征）；</p>
<p>• 病史特征（例如，既往疾病发作、风险因素）；</p>
<p>• 合并症（伴随疾病）；</p>
<p>• 身体功能状态（例如卡诺夫斯基评分、世界卫生组织表现评分）；</p>
<p>• 主观健康状况和生活质量（心理、认知、社会心理功能）。</p>
<p>这些类别的相关性将取决于具体的应用场景。值得注意的是，不同研究中对预测因子的定义可能会有所不同。例如，社会经济地位（SES）可以通过多种方式来定义，考虑到患者的工作状态、收入和&#x2F;或教育程度。此外，有时SES指标并不是在个体水平上确定的，而是在普查水平上确定的（例如在分析SEER-Medicare数据时的“生态SES”）。种族可以通过各种方式来定义，有时是通过自我报告而不是根据某些预先定义的规则确定的。合并症的定义和评分系统仍在发展之中。定义的变异对预测模型的泛化性构成严重威胁。目前已经采取了一些措施来定义“共同数据元素”，这将提高跨研究中预测因子的可比性。另一个区分是将患者的病情与其体质区分开来。病情可能在疾病类型和严重程度、病史特征、合并症、身体和主观健康状况等方面反映出来。体质可能特别与年龄和性别等人口统计学因素相关。例如，相同类型的创伤（反映在患者病情中）会对不同年龄的患者产生不同的影响（体质）。未来，遗传特征将更广泛地被用于疾病预测。人类基因组的固有变异，如多态性和突变，可能被视为患者体质的指标。其他遗传特征，例如恶性肿瘤的基因组特征，可能更适合被视为肿瘤亚型的指标，以反映病情。</p>
<h3 id="预测因子的成本"><a href="#预测因子的成本" class="headerlink" title="预测因子的成本"></a><strong>预测因子的成本</strong></h3><p>预测因子可能需要不同的成本，无论是在金钱方面还是在对患者的负担方面。在预测的情境中，应该优先考虑明显易于获取的信息，而不是那些更难获取的信息。因此，我们应该首先考虑诸如人口统计学和病史等特征，然后是简单的诊断检查，最后才是侵入性和&#x2F;或昂贵的检查。</p>
<h3 id="预后的决定因素"><a href="#预后的决定因素" class="headerlink" title="预后的决定因素"></a><strong>预后的决定因素</strong></h3><p>预后也可以被视为一个相互作用的因果三角关系。预测因子可以分为环境（例如，社会经济条件、医疗保健获取和质量、气候）、宿主（例如人口、行为、心理社会、病前生物因素）和疾病（例如影像、病理生理、基因组、蛋白质组、代谢组因素）。</p>
<p><img src="https://pic1.zhimg.com/80/v2-be67166d54851dcb2247d941a7f7f2a8_720w.webp" alt="预后可能被认为是由与环境、宿主和疾病相关的预测因素决定的。"></p>
<h3 id="肿瘤学中的预后"><a href="#肿瘤学中的预后" class="headerlink" title="肿瘤学中的预后"></a><strong>肿瘤学中的预后</strong></h3><p>对于肿瘤学中的预后，建议将患者、肿瘤和治疗相关的因素分开。患者特征包括人口统计学特征（年龄、性别、种族&#x2F;民族、社会经济地位）、合并症和功能状态。肿瘤特征包括疾病范围（例如，TNM 分期）、病理学，有时还包括肿瘤标志物。治疗通常包括手术、化疗和放疗等以及联合治疗。</p>
<p><img src="https://pic1.zhimg.com/80/v2-497ab4ce54255c390af7b63da7649728_720w.webp" alt="癌症患者的预后可以被认为是由与肿瘤、患者和治疗相关的预测因素所决定的"></p>
<h2 id="预测因子的可靠性"><a href="#预测因子的可靠性" class="headerlink" title="预测因子的可靠性"></a><strong>预测因子的可靠性</strong></h2><h3 id="观察者变异性"><a href="#观察者变异性" class="headerlink" title="观察者变异性"></a><strong>观察者变异性</strong></h3><p>通常情况下，我们更喜欢那些被清晰定义并可靠测量的预测因子。实际上，观察者变异对许多测量来说是一个问题。例如，不同领域的专业人士包括病理学家，他们可能会对组织标本进行组织学、细胞计数、细胞染色等评分，以及放射科医生，他们可能对X光、CT扫描、MRI扫描和超声测量等进行评分。这种变异通常用kappa统计量来量化。<strong>观察者间和观察者内的变异可能很大，这将反映在较低的kappa值中。这种测量误差将会给预测模型的泛化性带来挑战</strong>。</p>
<h3 id="示例：Barrett食管的组织学"><a href="#示例：Barrett食管的组织学" class="headerlink" title="示例：Barrett食管的组织学"></a><strong>示例：Barrett食管的组织学</strong></h3><p>Barrett食管是一种癌前病变。在高级别异型增生的情况下，有时会进行手术，而其他医生则可能直到患者诊断为腺癌时才会进行根治术。对于Barrett食管组织学读片在高级别异型增生或腺癌方面的一致性旗鼓相当，Kappa值约为0.4。无异型增生和低级别异型增生之间的一致性甚至更低。由于观察者变异，在仅使用专家评分，或者在意见不一致的情况下需要额外的专家意见。此外，还可以与专家建立共识，例如，由两位专家评分，并在他们意见不一致时再请求第三位专家的意见 。</p>
<h3 id="生物变异性"><a href="#生物变异性" class="headerlink" title="生物变异性"></a><strong>生物变异性</strong></h3><p>除了观察者变异，某些测量结果容易受到生物变异的影响。例如血压，通常至少要进行两次测量，最好是多次，而且时间上要有一定的间隔。</p>
<h3 id="回归稀释偏倚"><a href="#回归稀释偏倚" class="headerlink" title="回归稀释偏倚"></a><strong>回归稀释偏倚</strong></h3><p>回归稀释偏倚是指在进行回归分析时由于测量误差或不准确度引起的偏倚现象。当自变量或因变量中存在测量误差或变异性时，估计的回归系数通常会偏离其真实值，导致估计结果不准确。这种偏倚会导致对变量之间关系的误解，从而影响到结果的解释和预测能力。在数据分析和研究中，识别和纠正回归稀释偏差是十分重要的，以确保得到准确可靠的结果。可以通过重复不可靠的测量来解决回归稀释偏倚，可以由同一观察者进行（例如，使用3次血压测量的平均值），也可以由不同观察者进行（例如，由放射科医生对乳腺X线进行双重读片）。</p>
<h3 id="示例：二分变量可靠性研究示例"><a href="#示例：二分变量可靠性研究示例" class="headerlink" title="示例：二分变量可靠性研究示例"></a><strong>示例：二分变量可靠性研究示例</strong></h3><p>假设我们有一个二分变量，其值实际上为 0 或 1，假设两个观察者对预测变量的判断是独立的。若他们的判断与真实的预测因子状态一致，敏感性为 80%（如果 true &#x3D; 1，观察者得分 1），特异性为 80%（如果 true &#x3D; 0，观察者得分 0）。</p>
<p><img src="https://pic4.zhimg.com/80/v2-41f5701ecd20fddff5f531af52e322ef_720w.webp" alt="观察者确定真实预测状态的敏感性和特异性（敏感性 = 特异性 = 80%）如果两个观察者独立地对预测变量进行评分并且没有相关性，则观察者彼此一致，kappa 仅为 0.36。"></p>
<p><img src="https://pic1.zhimg.com/80/v2-3e803840281487ba39d1a5617719e95c_720w.webp" alt="观察者1和观察者2之间的一致性（kappa = 0.36），Kappa= (观察符合率-机遇符合率)/ (100%-机遇符合率)）真实的预测变量状态可以很好地预测结局，OR为 4。观察到的预测变量状态的预测性能大打折扣，OR为 2.25。同样，判别能力也不如真实的预测变量状态（c统计量从0.67下降到0.60）。"></p>
<p><img src="https://pic2.zhimg.com/80/v2-4f63af6084ea3233078cdf2830b94159_720w.webp" alt="真实预测状态和观察到的预测状态的结局的相关性"></p>
<h3 id="预测因子的选择"><a href="#预测因子的选择" class="headerlink" title="预测因子的选择"></a><strong>预测因子的选择</strong></h3><p>在病因学研究中，我们通常会致力于对预测因子进行最佳评估。我们将关注可能发生的各种信息偏倚。在预测模型的背景下，我们可以更加务实。如果我们的目标是开发一个适用于日常实践的模型，我们应该使用与日常实践一致的定义和评分标准。例如，如果是否进行手术的医疗决策是根据当地病理报告而不是专家意见进行的，那么应该考虑将当地病理报告纳入适用于当地环境的预测模型中。这种不太可靠的评估将影响预测模型的性能，因为预后关系将受到干扰。如果错误分类是随机的，那么实际的关联将被稀释。在实践中，预测模型往往包括相当容易获得、成本不太高且可以很好测量的预测因子。如果在不同测量精度的情况下应用预测模型，则需要谨慎，因为这种差异将影响模型的泛化能力。</p>
<h2 id="结局"><a href="#结局" class="headerlink" title="结局"></a><strong>结局</strong></h2><h3 id="结局的类型"><a href="#结局的类型" class="headerlink" title="结局的类型"></a><strong>结局的类型</strong></h3><p>预测模型的结局应该具有相关性，无论是从应用医学的角度还是从研究的角度来看。从医学的角度来看，“硬”终点通常更受青睐。尤其是在预后研究中，死亡通常被用作终点。对于许多急性和慢性疾病以及许多治疗方案而言，死亡风险是相关的。在其他疾病中，非致命事件可能更为相关，包括患者为中心的结局，如生活质量问卷的得分，或者更广泛的疾病负担指标。</p>
<p><img src="https://pic1.zhimg.com/80/v2-27f4cb58bd771f847cd00ec9026827b8_720w.webp" alt="预后结局示例"></p>
<h3 id="生存终点"><a href="#生存终点" class="headerlink" title="生存终点"></a><strong>生存终点</strong></h3><p>预测模型通常需要考虑生存终点的选择，无论是在相对较短的随访期（例如，30天死亡率）还是在更长的随访期（其中一些患者可能被删失）。当考虑特定原因的死亡时，需要可靠地评估死亡原因。如果死亡原因未知，可以计算相对存活率，这在癌症研究中尤其流行。某种癌症患者的死亡率与普通人群的死亡率进行比较，这种差异可以被认为是由于癌症引起的死亡。相对存活率估计的优缺点目前尚存在争议。<strong>有些人还建议研究在诊断后已存活了一些年份的患者的条件存活率，或者其他时间段的相对存活率。这些指标有时可能比从诊断时间起的5年相对存活率更有意义，对临床管理和预后更为有益。</strong>也有人提出，中位生存时间比5年相对存活率可以更好地反应生存，特别是当生存时间较短时，生存时间的差异作为效果度量，而不是相对风险的度量，如风险比。</p>
<h3 id="示例：癌症登记处的-5-年相对生存率"><a href="#示例：癌症登记处的-5-年相对生存率" class="headerlink" title="示例：癌症登记处的 5 年相对生存率"></a><strong>示例：癌症登记处的 5 年相对生存率</strong></h3><p>研究了 1990-1999 年期间登记在 SEER 登记处的患者的五年相对生存率。被诊断患有癌症的人的 5 年相对生存率为 63%，且不同部位肿瘤和诊断时不同分期的患者的存活率存在很大差异。自诊断以后，五年相对生存率随着时间的推移而增加。例如，被诊断患有前列腺癌、女性乳腺癌、子宫体癌和膀胱癌的患者，诊断后8年的相对生存率超过75%。</p>
<h3 id="复合终点"><a href="#复合终点" class="headerlink" title="复合终点"></a><strong>复合终点</strong></h3><p>有时将死亡率与非致命事件结合起来定义为复合终点。其在心血管研究中特别流行。例如，弗雷明汉模型，将心血管事件定义为致死性或非致死性心肌梗死、猝死或心绞痛（稳定或不稳定）来预测一般人群中的心血管疾病发生率。<strong>复合终点的优点是可以增加有效样本量，从而增强统计效能，限制是必须对每个终点成分假设类似的预后关联</strong>。</p>
<h3 id="示例：心血管事件复合终点"><a href="#示例：心血管事件复合终点" class="headerlink" title="示例：心血管事件复合终点"></a><strong>示例：心血管事件复合终点</strong></h3><p>针对 949 名失代偿性心力衰竭患者开发一个预测模型。结局是 60 天死亡率和 60 天死亡或再住院的复合终点。该模型对于死亡率模型的区分力很大（c 统计量 0.77），但对于复合终点（c 统计量 0.69）则较小。这些发现与急性冠状动脉综合征的预测一致，其中死亡率的预测性能优于死亡率或心肌（再）梗死的复合终点。</p>
<h3 id="预后结局的选择"><a href="#预后结局的选择" class="headerlink" title="预后结局的选择"></a><strong>预后结局的选择</strong></h3><p>预后结局的选择应视具体情况而定，但结局的测量应尽可能可靠。<strong>使用预测变量的实用定义来开发预测模型有助于模型的未来使用，但结局的确定应与病因学研究或随机临床试验相似</strong>。未来，决策将基于模型的预测。因此，预测需要基于与精确确定的结局之间的稳健统计学关联。从统计学角度来看，连续性结局更具统计效能。然而在实践中，二分类结局更加常见，使得逻辑回归和 Cox 回归成为医学中最常见的预测模型。</p>
<h3 id="诊断终点"><a href="#诊断终点" class="headerlink" title="诊断终点"></a><strong>诊断终点</strong></h3><p>诊断研究的结局是潜在的疾病，需要根据参考标准来定义。参考标准有时可以是解剖学的、血液或脑脊液培养物（例如，传染病）、血管造影等高质量的诊断方法（冠心病）或组织学检查（例如肿瘤学）。当缺乏可接受的参考标准时，诊断测试的结果可以与潜在类别分析中的相关其他临床特征和未来临床事件相关。当治疗和预后直接取决于诊断时，潜在诊断的相关性可能很高。通常，诊断涵盖一系列或多或少严重的疾病，并且需要进行长期结果评估。这在评估较新的成像技术时尤其重要，该技术可以检测以前未被注意到的疾病。</p>
<h3 id="示例：食管癌-PET-扫描"><a href="#示例：食管癌-PET-扫描" class="headerlink" title="示例：食管癌 PET 扫描"></a><strong>示例：食管癌 PET 扫描</strong></h3><p>对于食管癌，与单独的 CT 扫描相比，正电子发射断层扫描 (PET) 扫描可提供有关疾病范围的更多信息。然而，额外检测到的转移的临床相关性只能在比较研究中确定，最好是随机对照试验。而诊断更多转移瘤不足以使 PET&#x2F;CT 在临床上发挥作用。</p>
<h2 id="生物标志物的开发"><a href="#生物标志物的开发" class="headerlink" title="生物标志物的开发"></a><strong>生物标志物的开发</strong></h2><p>Pepe 提出了一种<strong>分阶段的方法</strong>来开发预测性生物标志物，特别是用于癌症的早期检测。这些阶段也与预测模型的开发和改进相关，这可能会为传统的临床特征添加新的生物标志物。开发过程始于专注于分类性能的小型研究，终于对人群影响的大型研究。目的是尽早选择潜在的标记物，同时认识到小型早期研究并不能回答需要解决的最终问题。例如，Pepe 考虑开发一种用于癌症筛查的生物标记物。<strong>第一阶段</strong>是探索性的，可能会考虑基因表达阵列或蛋白质质谱分析，为生物标志物的发现产生高维数据。实验室之间的可重复性是进入第二阶段之前需要考虑的一个方面，<strong>在第二阶段</strong>中，将基于人群的癌症病例和基于人群的无癌症对照病例之间的有前景的生物标志物进行比较。<strong>第三阶段</strong>是病例对照研究中更彻底的评估，以确定标记物是否可以检测亚临床疾病。<strong>在第四阶段</strong>，标记物可以前瞻性地应用于人群中作为筛选测试。最后，<strong>第五阶段</strong>通过测量对临床相关结局（例如死亡率和医疗费用）的影响来解决筛查的总体影响。</p>
<p><img src="https://pic1.zhimg.com/80/v2-c47cdaa227fdb3ac0b3c8e3fa95ef134_720w.webp" alt="用于癌症筛查的生物标志物的开发阶段"></p>
<p>在探索性第一阶段，使用“方便样本”可能是可以接受的，但这可能会导致生物标志物评估中的疾病谱偏倚。在第二阶段，需要基于人群的样本来进行简单的病例对照设计。在第三阶段，我们需要在癌症患者的疾病出现临床症状之前采集样本。巢式病例对照研究设计对于队列研究的数据非常有效。对于第四阶段，需要进行前瞻性队列研究来确定早期检测到的疾病的特征和可治疗性。最后，需要进行随机对照试验来公正地评估筛查的影响。</p>
<h2 id="统计效能和信度估计"><a href="#统计效能和信度估计" class="headerlink" title="统计效能和信度估计"></a><strong>统计效能和信度估计</strong></h2><p>在临床预测模型的设计中，一个重要问题是，研究需要多大规模才能具有足够的统计学效能来解决主要的研究问题，并可靠地估计参数以进行预测建模。<strong>需要注意的是，在二分类预测的背景下，样本大小取决于事件数量和预测因子的分布的组合</strong>；我们应特别关注“稀疏数据”。下面，我们将讨论功效考虑因素，以研究特定预测因子的影响，并开发能够提供可靠预测的预测模型。</p>
<h3 id="样本量，以确定预测效应"><a href="#样本量，以确定预测效应" class="headerlink" title="样本量，以确定预测效应"></a><strong>样本量，以确定预测效应</strong></h3><p>我们可能主要感兴趣的是特定预测因子对诊断或预后结局的影响。然后，我们可能旨在测试该预测变量的统计显着性效果。这导致了与治疗效果测试类似的样本量考虑，例如在随机对照试验中。对于这种<strong>单变量测试</strong>，样本量估计是直截了当的，所需的样本量由可接受的I类和II类错误的选择决定。为了统计显著性，I类错误通常设置为5%。II类错误决定了统计效能。例如，设置为 20%对应80% 的效能。其他考虑因素包括效应估计的可变性。</p>
<p><strong>对于二分类结局的二分类预测因子</strong>，预测因子的普遍性和结局的发生率（“事件率”）非常重要。最终，效应的大小决定了所需的样本量，通常，需要更大的样本量来检测更小的效应。为了说明问题，在下图中我们说明了二分类结局中二分类预测因子的统计效能。我们发现，事件率非常低或非常高时，所需的样本量会急剧增加，当事件率在20-80%之间时所需的样本量较为恒定。在OR为1.5的情况下，为了达到80%的效能，假设结局发生率为10%（200个事件），需要大约2000名受试者；假设结局发生率为20%（200个事件），需要大约1000名受试者；假设结局发生率为50%（400个事件），则需要大约800名受试者。<strong>因此，在事件发生率较低的情况下，事件数量是主导因素</strong>。</p>
<p><img src="https://pic3.zhimg.com/80/v2-f45cfa4d8342c31271d239ca892490ce_720w.webp" alt="事件率（结局发生率）范围从 0 到 100% 的样本量相对应的统计效能。考虑二分类预测因子，其患病率为 50%，OR为 1.5。"></p>
<p>接下来，我们说明<strong>统计效能也与二分类预测变量的患病率直接相关</strong>。我们考虑 1 到 3 之间的比值比，这在医学预测研究中经常遇到。在 500 名受试者的样本量中，结局的发生率为 50%，若要达到 80% 功效，在比值比为 2 和 3 的情况下，预测因子所需要对应的患病率分别为 16% 和 5.5%。在事件率为50%，OR值为 1.2 和 1.5 ，若要达到80%功效则分别需要 3800 和 800个样本量。事件发生率为 10% 时，效能显着降低（右图）。OR为 3 则需要 18%（而不是 5.5%）的预测因子患病率才能获得 80% 的功效。如果没有影响 (OR &#x3D; 1)，根据定义，统计显着性预计为 5%。</p>
<p><img src="https://pic1.zhimg.com/80/v2-138b9b6f9ba4c702fdb66d8c9dce9240_720w.webp" alt="与二分类预测变量的患病率相关的统计功效，在 500 名受试者的样本中，比值比为 1 到 3。事件率为 50%（左图）和 10%（右图）。"></p>
<h3 id="用于可靠建模的样本大小"><a href="#用于可靠建模的样本大小" class="headerlink" title="用于可靠建模的样本大小"></a><strong>用于可靠建模的样本大小</strong></h3><p>我们可以不再将注意力集中在预测因素上，而是将其集中在由预测模型提供的预测可靠性上。<strong>预测模型的样本量要求通常被表述为“每个变量至少 10 个事件(10 EPV)”。</strong>从技术上讲，我们应该考虑模型候选预测因子的自由度 (df)。EPV 概念假设每个变量都有 1 df。请注意，从一组候选预测变量中以数据驱动方式选择预测变量不会提高 EPV 值。此外，我们需要考虑总样本量，或者事件与非事件之间的比率。如果事件发生率为50%，那么对于给定数量的事件，统计功效要低于事件发生率较低的情况，比如10%。例如，对于100个事件，总样本量分别为200和1000。<strong>在病例对照研究中，经验法则是，如果对照数量增加到 4:1 以上，统计效能不会增加太多；因此，当事件发生率低于 20%（事件：非事件比率 1:4）时，事件数量将成为主导因素。上面的图像说明也证实了这一模式。因此，对于 20% 到 80% 之间的概率估计，与更极端的事件发生率相比，将适用更高的 EPV。</strong></p>
<p>相对较低的 EPV 值可能适用于调整混杂因素的回归分析。即使EPV降低到较低的水平，也最好包括一些潜在的混杂因素。回归分析在较低的EPV值下也可以进行技术上的良好操作，尽管可能需要考虑某种类型的收缩，例如使用Firth回归。<strong>因此，在校正了混杂因素的分析中，即使EPV低于10，也是可行的。</strong>许多人建议至少使用 10 到 20 EPV 才能获得合理可靠的预测 。小于 10 EPV 构建的医学预测模型通常会过度拟合，并且其表现性能可能比考虑较少候选预测变量的简单模型更差。限制候选预测变量的数量可能会将 EVP 增加到至少 10。对于预先指定的模型，EPV 至少为 20 时可能不需要统计收缩。用于从更大的候选预测变量集中数据驱动选择预测变量的 EPV 值可能高达 50。使用一些灵活的机器学习算法（例如随机森林和神经网络）进行稳定的模型估计可能需要更高的 EPV 值（超过 200）。</p>
<p><strong>当然，EPV规则的使用也有以下局限性：</strong></p>
<p>• 除了事件数量之外，非事件数量也很重要，特别是对于 20% 到 80% 之间的事件发生率。</p>
<p>• 预测变量效应的分布和大小以及每个分类预测变量类别的事件数量也很重要。</p>
<p>Riley等人提出了在二分类结局或时间-事件结局预后分析时样本量计算的三个标准：</p>
<p><strong>（1）预测效应估计的乐观程度较低；由收缩系数 ≥0.9 定义；</strong></p>
<p><strong>（2）R2和调整后的 Nagelkerke R2差异较小；定义为 0.05；</strong></p>
<p><strong>（3）平均预测结局值（模型截距）的精确估计，例如，用±0.1的误差幅度定义。</strong></p>
<p>这些标准可以用于特定的情境，其中包含一些候选预测因子和模型预期的R2。然后，我们可能会提出符合所有标准的样本大小。与任何样本大小计算一样，我们需要对这些参数进行估计，例如，可以参考以往研究的结果。一些界限是较为随意的，例如，许多人可能会接受0.8的缩减系数，而不是0.9，这会导致对于该标准的较低样本大小需求。限制预期缩减的想法已经由Harrell等人提出，即拟合一个包含所有候选预测因子的完整预测模型，检查模型拟合的强度（模型x2），然后考虑在建模过程中可能要花费的自由度。</p>
<p>Harrell还提出，我们可能至少希望用合理的精度估计平均风险。用于在20%至80%事件率范围内估计风险的±0.1的误差范围的下限可能为96个事件。要在p &#x3D; 0.5周围实现±0.05的误差范围，需要n &#x3D; 384（192个事件）。再次强调，这样的限制（±0.1或±0.05）是相当随意的。</p>
<p>具体而言，初步建议可能如下：</p>
<p><strong>•要实现平均风险的可靠估计，至少需要 100 个事件。• 如果事件发生率&lt;20%，则目标是至少10 个EPV，最好是20 个，以便建立可靠的预测模型；如果事件发生率在20% 到80% 之间，则需要更高的EPV。</strong></p>
<p><strong>• 允许特定情况增加所需的样本量，例如用于建模的预测因子的发生率很低。</strong></p>
<p>请注意，一旦数据可用，我们应该调整我们的建模策略，以最大程度地提高可靠预测模型的机会，至少是在内部有效的。即使在相对有利的EPV情况下，稀疏数据也可能会发生。在当前实践中，许多预测模型是基于少于100个事件并且EPV值低于10开发的。这可能导致预测研究的浪费。</p>
<p><img src="https://pic1.zhimg.com/80/v2-f7d65cb2d2f8abe74c55c3fdcd1129d4_720w.webp" alt="开发和验证预测模型的样本量注意事项"></p>
<h3 id="用于可靠验证的样本量"><a href="#用于可靠验证的样本量" class="headerlink" title="用于可靠验证的样本量"></a><strong>用于可靠验证的样本量</strong></h3><p>与模型开发研究类似，外部验证研究也需要充足的样本量。模拟分析表明，验证研究应包括至少100个事件，最好更多。这个数字在其他研究中也得到了证实，当我们希望获得性能可靠估计时，这一角度也适用。与模型开发类似，模型验证实践目前没有遵循这一最小事件数量的指导，导致预测研究中的研究浪费。作为单一验证的延伸，检验预测模型在一系列情景中的外部效度同样非常重要。随后可以使用多级（或随机效应）模型。准确估计多级 logistic 回归模型的模型参数和方差成分可能需要至少 50 组，每组 50 名受试者。对于验证，我们的目标也是获得对于不同设置间异质性的可靠估计。这种异质性估计更依赖于设置（“组”）的数量，而不是每组的个体数。从技术上讲，建模可能需要至少五组，而一些人建议至少十组，模拟研究支持在估计异质性时至少需要 50 组以降低偏差。总之，单一的外部验证研究需要至少 100 个事件才具有意义。在效度中评估不同组间的异质性需要大量分组，最好是 50 个或更多。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>理想情况下，预后研究应设计为前瞻性队列研究，其中患者的选择和预测因子的定义需要提前确定。当然也可以使用来自临床试验的数据，尽管这种情况下目标人群的代表性会有所限制。数据也可以来自回顾性设计、注册研究和病例-对照研究，每种设计都有其优点和局限性。诊断性研究通常是横断面设计，并且应提前选择所有疑似患有感兴趣疾病的患者。预测因子可以从实用的角度定义，并覆盖疾病相关的领域。预测模型的结局应该被准确测量，通常更偏向于选择像死亡率这样的硬性终点。在任何研究设计中，我们应该尽可能追求大样本量以进行可靠的测试和预测因子效应的估计，可靠的模型构建以及可靠的模型性能评估。对于任何模型的开发或验证，至少需要100个事件，并且对于更详细的建模和解决更精细的研究问题，则需要更多的事件。拥有100个事件的模型开发样本相当于具有EPV&#x3D;10（10个候选预测因子）。如果候选的预测因子个数超过10个，则需要更多出现结局事件的样本。如果确保模型有良好的泛化性，则需要更多的样本进行多种环境的验证，且数据需要来自不同的环境。</p>
<p><strong>持续更新中……</strong></p>
<hr>
<p>供稿：圆圆<br>编排：Roger不言</p>
]]></content>
      <categories>
        <category>临床预测模型系列</category>
      </categories>
      <tags>
        <tag>临床预测模型</tag>
      </tags>
  </entry>
  <entry>
    <title>python与机器学习系列</title>
    <url>/year/030346613.html</url>
    <content><![CDATA[<p><img src="https://pic1.zhimg.com/80/v2-c9e5695bb4812686b2897aec73d3152c_720w.webp" alt="img"></p>
<span id="more"></span>

<p>从这次开始，我们将一起学习Python与机器学习。因为我们之前的R与机器学习系列已经系统地介绍了各种机器学习的特点及其实现过程，相信大家对机器学习有了一定的了解和基础。所以我们选择Chris Albon的著作Machine Learning with Python Cookbook-Practical Solutions from Preprocessing to Deep Learning作为我们的学习参考。</p>
<p>关于为什么要使用Python，我们之前其实已经介绍了Python在机器学习以及大数据处理中的优势，这里不再赘述。</p>
<p>关于Python的基础知识，其实跟R基础类似，小编觉得需要在实践中去掌握并巩固基础知识。因为单纯的去看偏理论的基础知识相当枯燥。但是，这不代表基础知识不重要，相反，基础知识在后面的学习中至关重要。所以，想跟着这个系列学习的小伙伴最好是自己学习一些Python的基础知识，方便后面的学习。其实语言都是相通的，如果你学习过R基础，那么Python的语法结果这些应该很快能掌握。</p>
<p>关于软件，小编使用的是Python的虚拟环境，Anaconda。如何安装、如何使用，这些在网上有大量的教程，请自行参考。</p>
<p>具体Anoconda的安装和相关简介可以看以下这篇介绍：</p>
<blockquote>
<p>Anaconda介绍、安装及使用教程</p>
<p>知乎-Anaconda介绍、安装及使用教程</p>
</blockquote>
<hr>
<p>NumPy是Python机器学习技术栈的基础。NumPy能对机器学习中常用的数据结构——向量（vector） 、 矩阵（matrice） 、 张量（tensor） —进行高效的操作。本章将介绍在进行机器学习的过程中可能经常遇到的NumPy作。</p>
<p><strong>Numpy简介</strong></p>
<p>NumPy（Numerical Python的缩写）是Python中一个重要的数值计算库，它提供了用于处理大型多维数组和矩阵的数据结构，以及用于执行这些数组上的数学运算的函数。NumPy是数据科学、机器学习、科学计算等领域的核心库，具有以下重要特点和功能：</p>
<ul>
<li>多维数组（ndarray）：NumPy的核心数据结构是多维数组（也称为ndarray），它是一个固定大小、可变的数组，可以容纳相同类型的数据。这些数组可以是一维、二维或更高维的，适用于各种数值和数据处理任务。</li>
<li>广播（Broadcasting）：NumPy具有强大的广播功能，允许在不同形状的数组之间进行运算，而无需显式循环。这使得元素级操作更加方便和高效。</li>
<li>数学函数：NumPy提供了大量的数学、统计和线性代数函数，包括各种数学运算、随机数生成、傅立叶变换、矩阵操作等。</li>
<li>互操作性：NumPy与其他Python库相互兼容，特别是与SciPy（科学计算库）、Matplotlib（绘图库）和pandas（数据分析库）等。这意味着你可以将NumPy与其他库结合使用，构建强大的数据处理和分析工具。</li>
<li>性能优化：NumPy的底层实现使用了高度优化的C和Fortran代码，因此在处理大规模数据时具有出色的性能。此外，NumPy还提供了内存管理工具，可以有效管理大型数据集的内存。</li>
<li>开源和社区支持：NumPy是一个开源项目，拥有庞大的活跃社区，提供了广泛的文档、教程和支持资源。这使得它成为学习和使用数值计算的理想选择。</li>
</ul>
<h1 id="Python中的向量、-矩阵和数组"><a href="#Python中的向量、-矩阵和数组" class="headerlink" title="Python中的向量、 矩阵和数组"></a><strong>Python中的向量、 矩阵和数组</strong></h1><h2 id="创建向量"><a href="#创建向量" class="headerlink" title="创建向量"></a><strong>创建向量</strong></h2><p>在数学和计算机科学中，向量是一个有序的数值序列，它是一个基本的数学对象，用于表示和处理多种类型的数据和信息。向量通常用于描述空间中的点、物理量的大小和方向、数据的集合等等。</p>
<p>向量是一个有序的数值序列，每个元素都按照特定的顺序排列。这个顺序非常重要，因为它定义了向量的唯一性。向量的维度表示向量中包含的元素数量。一维向量包含一个元素，二维向量包含两个元素，以此类推。向量可以进行各种数学运算，包括加法、减法、数乘、点积（内积）等。</p>
<p>向量通常用方括号或圆括号表示，如 [1, 2, 3] 或 (1, 2, 3)。</p>
<p>NumPy的主要数据结构是多维数组（array）。要创建一个向量， 只需简单地创建一个一维数组即可。和向量相似， 对这些数组， 我们能水平地（也就是行） 或垂直地（也就是列） 表示。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建一个向量</span></span><br><span class="line"><span class="comment"># 加载库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建一个行向量</span></span><br><span class="line">vector_row = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="comment"># 创建一个列向量</span></span><br><span class="line">vector_column = np.array([[<span class="number">1</span>],</span><br><span class="line">                          [<span class="number">2</span>],</span><br><span class="line">                          [<span class="number">3</span>],</span><br><span class="line">                          [<span class="number">4</span>],</span><br><span class="line">                          [<span class="number">5</span>],</span><br><span class="line">                          [<span class="number">6</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="创建矩阵"><a href="#创建矩阵" class="headerlink" title="创建矩阵"></a><strong>创建矩阵</strong></h2><p>矩阵是由数字排列成的矩形数组。矩阵由行和列组成，每个元素都可以在矩阵中唯一地通过其行和列的索引来标识。一般情况下，矩阵中的元素可以是数字（实数、复数）或其他可定义的数学对象。</p>
<p>矩阵中的元素按行和列排列。行通常从上到下编号，列通常从左到右编号。矩阵的维度由其行数和列数确定。如果一个矩阵有m行和n列，通常会称其为mxn矩阵，或者简称为“m×n矩阵”。矩阵中的每个元素可以是任何数值，包括整数、小数、复数等。矩阵支持一系列运算，包括加法、减法、乘法、转置等。</p>
<p>我们可以通过创建一个NumPy二维数组来创建一个矩阵。通过以下代码，我们创建了一个3行3列的矩阵（二维数组）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建一个矩阵</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                   [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">                   [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]])</span><br></pre></td></tr></table></figure>

<h2 id="创建稀疏矩阵"><a href="#创建稀疏矩阵" class="headerlink" title="创建稀疏矩阵"></a><strong>创建稀疏矩阵</strong></h2><p>稀疏矩阵（Sparse Matrix）是一种特殊类型的矩阵，其中大多数元素都是零。与稠密矩阵（Dense Matrix）相比，稀疏矩阵具有许多零元素，这些零元素占据了矩阵的大部分空间。在实际应用中，许多数据集或问题的矩阵表示都是稀疏的，因此稀疏矩阵在各种领域的数据分析和计算中非常常见。</p>
<p>稀疏矩阵通常以压缩的形式存储，以节省内存空间。有几种常见的表示稀疏矩阵的方法，包括：</p>
<ul>
<li>压缩稀疏列（CSC）：在CSC表示中，矩阵的每一列都存储为一个单独的数据结构，包括非零元素的值、非零元素的行索引和列指针。这种表示适合按列访问矩阵。</li>
<li>压缩稀疏行（CSR）：在CSR表示中，矩阵的每一行都存储为一个单独的数据结构，包括非零元素的值、非零元素的列索引和行指针。这种表示适合按行访问矩阵。</li>
<li>坐标列表（COO）：在COO表示中，矩阵中的每个非零元素都存储为一个单独的数据结构，包括其行索引、列索引和值。这种表示适合构建稀疏矩阵。</li>
</ul>
<p><strong>稀疏矩阵的使用可以节省内存，提高计算效率，因为在进行矩阵运算时不必考虑大量的零元素</strong>。在机器学习中， 数据集十分庞大且其中大部分元素都是零的情况很常见。举个例子， 想象一个矩阵， 列元素是Netflix上的所有电影， 行元素是Netflix的所有用户， 矩阵中元素的值代表对于某部电影每个用户看过几次。这个矩阵将会拥有成千上万列以及数百万行！但由于大多数用户只看过一部分电影， 所以绝大多数元素的值是零。<strong>稀疏矩阵只保存非零元素并假设剩余元素的值都是零， 这样能节省大量的计算成本</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> sparse</span><br><span class="line"><span class="comment"># 创建矩阵</span></span><br><span class="line">matrix = np.array([[<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                   [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                   [<span class="number">3</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="comment"># 创建压缩行 (CSR)矩阵</span></span><br><span class="line">matrix_sparse = sparse.csr_matrix(matrix)</span><br><span class="line"><span class="comment"># 查看稀疏矩阵</span></span><br><span class="line"><span class="built_in">print</span>(matrix_sparse)</span><br><span class="line"> <span class="comment"># (1, 1)  1</span></span><br><span class="line"> <span class="comment"># (2, 0)  3</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中， 我们创建了带有两个非零值的NumPy数组， 然后将其转换成一个稀疏矩阵。如果查看这个稀疏矩阵， 就能看到只有其中的非零值被保存下来了。</p>
<p>在压缩的稀疏行（CSR） 矩阵中， (1,1)和(2,0)用下标（下标的编号从0开始递增） 分别表示非零值1和3。例如， 元素1就位于矩阵的第二行和第二列。 </p>
<p>如果创建一个更大的矩阵， 而这个矩阵有更多的非零元素， 那么与普通矩阵相比， 稀疏矩阵的优势就体现出来了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个更大的矩阵</span></span><br><span class="line">matrix_large = np.array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                         [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                         [<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"><span class="comment"># 创建一个压缩行（CSR）矩阵</span></span><br><span class="line">matrix_large_sparse = sparse.csr_matrix(matrix_large)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看更大的稀疏矩阵</span></span><br><span class="line"><span class="built_in">print</span>(matrix_large_sparse)</span><br><span class="line">  <span class="comment"># (1, 1)  1</span></span><br><span class="line">  <span class="comment"># (2, 0)  3</span></span><br></pre></td></tr></table></figure>

<h2 id="选择元素"><a href="#选择元素" class="headerlink" title="选择元素"></a><strong>选择元素</strong></h2><p>NumPy数组的索引编号是从0开始的， 这意味着第一个元素的下标是0而不是1。此外， NumPy还提供了很多方式来选取元素或数组中的一组元素（即索引和切片）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个行向量</span></span><br><span class="line">vector = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="comment"># 创建一个矩阵</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                   [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">                   [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#选择向量的第三个元素</span></span><br><span class="line">vector[<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment">#选择矩阵的第二行第二列</span></span><br><span class="line">matrix[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个向量的所有元素</span></span><br><span class="line">vector[:]</span><br><span class="line"><span class="comment"># array([1, 2, 3, 4, 5, 6])</span></span><br><span class="line"><span class="comment"># 选择第3个元素及之前的元素</span></span><br><span class="line">vector[:<span class="number">3</span>]</span><br><span class="line"><span class="comment"># array([1, 2, 3])</span></span><br><span class="line"><span class="comment"># 选择第3个元素以后的元素</span></span><br><span class="line">vector[<span class="number">3</span>:]</span><br><span class="line"><span class="comment"># array([4, 5, 6])</span></span><br><span class="line"><span class="comment"># 选择最后一个元素</span></span><br><span class="line">vector[-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 选择矩阵的前两行和所有列</span></span><br><span class="line">matrix[:<span class="number">2</span>,:]</span><br><span class="line"><span class="comment"># array([[1, 2, 3],</span></span><br><span class="line"><span class="comment">#       [4, 5, 6]])</span></span><br><span class="line"><span class="comment"># 选择所有行和第2列</span></span><br><span class="line">matrix[:,<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># array([[2],</span></span><br><span class="line"><span class="comment">#        [5],</span></span><br><span class="line"><span class="comment">#        [8]])</span></span><br></pre></td></tr></table></figure>

<h2 id="展示矩阵的属性"><a href="#展示矩阵的属性" class="headerlink" title="展示矩阵的属性"></a><strong>展示矩阵的属性</strong></h2><p>我们可以使用使用shape、 size和ndim函数来展示一个矩阵的形状、 大小和维数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个矩阵</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">                   [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">                   [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="comment"># 查看矩阵的行数和列数</span></span><br><span class="line">matrix.shape</span><br><span class="line"><span class="comment"># (3, 4)</span></span><br><span class="line"><span class="comment"># 查看矩阵的元素数 (行 * 列)</span></span><br><span class="line">matrix.size</span><br><span class="line"><span class="comment"># 12</span></span><br><span class="line"><span class="comment"># 查看矩阵的维度</span></span><br><span class="line">matrix.ndim</span><br><span class="line"><span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<h2 id="对多个元素同时应用某个操作"><a href="#对多个元素同时应用某个操作" class="headerlink" title="对多个元素同时应用某个操作"></a><strong>对多个元素同时应用某个操作</strong></h2><p>NumPy的vectorize类将一个函数转换成另一个函数， 这个函数能把某个操作应用在数组的全部元素或一个切片上。值得注意的是， vectorize本质上是在对所有元素循环执行某个操作， 所以并不会提升性能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个矩阵</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">                   [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">                   [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="comment"># 创建一个函数，给返回输入值加上100</span></span><br><span class="line">add_100 = <span class="keyword">lambda</span> i: i + <span class="number">100</span></span><br><span class="line"><span class="comment"># 创建向量化函数</span></span><br><span class="line">vectorized_add_100 = np.vectorize(add_100)</span><br><span class="line"><span class="comment"># 将函数应用到矩阵中的所有元素</span></span><br><span class="line">vectorized_add_100(matrix)</span><br><span class="line"><span class="comment"># array([[101, 102, 103, 104],</span></span><br><span class="line"><span class="comment">#        [105, 106, 107, 108],</span></span><br><span class="line"><span class="comment">#        [109, 110, 111, 112]])</span></span><br></pre></td></tr></table></figure>

<p>使用NumPy的数组， 我们可以对两个维度不同的数组执行操作（这是一种叫作广播的方法） 。举个例子， 对于上述问题使用广播（broadcasting） 后， 我们的解决方案更简单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix+<span class="number">100</span></span><br><span class="line"><span class="comment"># array([[101, 102, 103, 104],</span></span><br><span class="line"><span class="comment">#        [105, 106, 107, 108],</span></span><br><span class="line"><span class="comment">#        [109, 110, 111, 112]])</span></span><br></pre></td></tr></table></figure>

<h2 id="找到最大值和最小值"><a href="#找到最大值和最小值" class="headerlink" title="找到最大值和最小值"></a><strong>找到最大值和最小值</strong></h2><p>我们可以使用NumPy的max和min函数计算一个数组的最大值或最小值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create matrix</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">                   [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">                   [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="comment"># 返回最大值的元素</span></span><br><span class="line">np.<span class="built_in">max</span>(matrix)</span><br><span class="line"><span class="comment"># 12</span></span><br><span class="line"><span class="comment"># 返回最小值的元素</span></span><br><span class="line">np.<span class="built_in">min</span>(matrix)</span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>求一个数组或一个数组的子集中元素的最大值和最小值是很常见的需求， 使用max和min方法很容易实现。而使用axis参数则可以对一个特定的坐标轴应用此操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回每一列的最大值</span></span><br><span class="line">np.<span class="built_in">max</span>(matrix, axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># array([ 9, 10, 11, 12])</span></span><br><span class="line"><span class="comment"># 返回每一行的最大值</span></span><br><span class="line">np.<span class="built_in">max</span>(matrix, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># array([ 4,  8, 12])</span></span><br></pre></td></tr></table></figure>

<h2 id="计算平均值、-方差和标准差"><a href="#计算平均值、-方差和标准差" class="headerlink" title="计算平均值、 方差和标准差"></a><strong>计算平均值、 方差和标准差</strong></h2><p>我们可以使用NumPy的mean、 var和std 函数来计算数组的一些描述性统计值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create matrix</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">                   [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">                   [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="comment"># 平均值</span></span><br><span class="line">np.mean(matrix)</span><br><span class="line"><span class="comment"># 6.5</span></span><br><span class="line"><span class="comment"># 方差</span></span><br><span class="line">np.var(matrix)</span><br><span class="line"><span class="comment"># 11.916666666666666</span></span><br><span class="line"><span class="comment"># 标准差</span></span><br><span class="line">np.std(matrix)</span><br><span class="line"><span class="comment"># 3.452052529534663</span></span><br></pre></td></tr></table></figure>

<p>当然，我们也可以计算每一列或者每一行的均值等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每一列的均值np.mean(matrix, axis=0)</span></span><br><span class="line"><span class="comment"># array([5., 6., 7., 8.])</span></span><br></pre></td></tr></table></figure>

<h2 id="矩阵变形"><a href="#矩阵变形" class="headerlink" title="矩阵变形"></a><strong>矩阵变形</strong></h2><p>我们可以使用NumPy的reshape函数在不改变元素值的前提下， 改变一个数组的形状（行数和列数）。reshape可以重构一个数组， 维持该数组原来的数据不变， 只改变行数和列数。唯一的要求就是原矩阵和新矩阵包含的元素数量必须相同（也就是大小相同） 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个4*3矩阵</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                   [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">                   [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">                   [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="comment"># 变形为2x6矩阵</span></span><br><span class="line">matrix.reshape(<span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line"><span class="comment"># array([[ 1, 2, 3, 4, 5, 6],</span></span><br><span class="line"><span class="comment">#        [ 7, 8, 9, 10, 11, 12]])</span></span><br></pre></td></tr></table></figure>

<p>reshape能传入一个非常有用的参数值-1， 表示可以“根据需要填充元素”， 所以reshape(1, -1)意味着矩阵的行数是1， 而列数则根据需要填充。</p>
<p>如果只提供一个整数作为参数， 那么reshape会返回一个长度为该整数值的一维数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix.reshape(<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># array([[ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12]])</span></span><br><span class="line">matrix.reshape(<span class="number">12</span>)</span><br><span class="line"><span class="comment"># array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12])</span></span><br></pre></td></tr></table></figure>

<h2 id="转置向量或矩阵"><a href="#转置向量或矩阵" class="headerlink" title="转置向量或矩阵"></a><strong>转置向量或矩阵</strong></h2><p>我们可以使用T函数转置一个向量或矩阵。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create matrix</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">                   [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">                   [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="comment"># 转置矩阵</span></span><br><span class="line">matrix.T</span><br><span class="line"><span class="comment"># array([[ 1,  5,  9],</span></span><br><span class="line"><span class="comment">#        [ 2,  6, 10],</span></span><br><span class="line"><span class="comment">#        [ 3,  7, 11],</span></span><br><span class="line"><span class="comment">#        [ 4,  8, 12]])</span></span><br></pre></td></tr></table></figure>

<p>转置在线性代数中是很常见的操作， 它将每个元素的行、 列下标互换。在线性代数范围外有一点常被忽视：严格来说一个向量是不能被转置的， 因为它只是值的集合。</p>
<p>转置一个向量通常是指将行向量转换为列向量（注意第2对括号） ， 或反向转换。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]).T</span><br><span class="line"><span class="comment"># array([1, 2, 3, 4, 5, 6])</span></span><br><span class="line"><span class="comment"># 转置行向量</span></span><br><span class="line">np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]).T</span><br><span class="line"><span class="comment"># array([[1],</span></span><br><span class="line"><span class="comment">#        [2],</span></span><br><span class="line"><span class="comment">#        [3],</span></span><br><span class="line"><span class="comment">#        [4],</span></span><br><span class="line"><span class="comment">#        [5],</span></span><br><span class="line"><span class="comment">#        [6]])</span></span><br></pre></td></tr></table></figure>

<h2 id="展开一个矩阵"><a href="#展开一个矩阵" class="headerlink" title="展开一个矩阵"></a><strong>展开一个矩阵</strong></h2><p>在Numpy中可以使用flatten将矩阵转换成一个一维数组。 此外，也可以使用reshape来创建一个行向量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 建立矩阵</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                   [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">                   [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="comment"># 展开矩阵</span></span><br><span class="line">matrix.flatten()</span><br><span class="line"><span class="comment"># array([1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line">matrix.reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="计算矩阵的秩"><a href="#计算矩阵的秩" class="headerlink" title="计算矩阵的秩"></a><strong>计算矩阵的秩</strong></h2><p>矩阵的秩（Rank）是一个重要的线性代数概念，它用于衡量矩阵中的线性独立性。矩阵的秩就是由它的列或行展开的向量空间的维数。我们可以使用NumPy中的线性代数方法matrix_rank计算矩阵的秩。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create matrix</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                   [<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>],</span><br><span class="line">                   [<span class="number">1</span>, <span class="number">1</span>, <span class="number">15</span>]])</span><br><span class="line"><span class="comment">#返回矩阵的秩</span></span><br><span class="line">np.linalg.matrix_rank(matrix)</span><br><span class="line"><span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<h2 id="计算行列式"><a href="#计算行列式" class="headerlink" title="计算行列式"></a><strong>计算行列式</strong></h2><p>矩阵的行列式（Determinant）是一个标量值，它与方阵（即行数等于列数的矩阵）相关联。行列式的计算通常用于线性代数中，具有许多重要的数学和工程应用。行列式用于描述矩阵的性质，如矩阵是否可逆、矩阵的秩、线性方程组的解等。对于一个n × n的方阵A，它的行列式通常表示为det(A)或|A|。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create matrix</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                  [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>],</span><br><span class="line">                  [<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="comment"># Return determinant of matrix</span></span><br><span class="line">np.linalg.det(matrix)</span><br><span class="line"><span class="comment"># 0.0</span></span><br></pre></td></tr></table></figure>

<h2 id="获取矩阵的对角线元素"><a href="#获取矩阵的对角线元素" class="headerlink" title="获取矩阵的对角线元素"></a><strong>获取矩阵的对角线元素</strong></h2><p>矩阵的对角线元素是指矩阵中位于从左上角到右下角的主对角线上的元素。主对角线是指行数和列数相等的情况下，矩阵的第1行、第1列、第2行、第2列等相交的位置上的元素。对角线元素通常表示为 <code>a[i][i]</code>，其中 <code>i</code> 是行索引和列索引相等的位置。对角线元素在矩阵理论和线性代数中具有重要的作用，它们有以下用途：</p>
<ul>
<li>矩阵的迹（Trace）：矩阵的迹是对角线元素的和，通常表示为 <code>Tr(A)</code>，其中 <code>A</code> 是矩阵。迹在计算中常用于一些数学证明和运算中，具有特殊的性质。</li>
<li>矩阵的特征值（Eigenvalues）：矩阵的特征值是矩阵线性变换中非常重要的概念，它们通过求解矩阵的特征方程获得。对角线元素对特征值的计算和性质具有影响。</li>
<li>矩阵的行列式（Determinant）：行列式是矩阵的一个标量值，对角线元素的乘积减去反对角线元素的乘积用于计算二维矩阵的行列式，而三维及更高维的矩阵行列式的计算也涉及到对角线元素。</li>
<li>矩阵的正定性：对角线元素在判断矩阵的正定性、半正定性、负定性等性质时起到关键作用。正定矩阵的对角线元素必须为正数。</li>
<li>对称矩阵：对角线元素通常在对称矩阵中具有特殊性质，因为对称矩阵的非对角线元素与其对应的对角线元素是相等的。</li>
<li>矩阵的压缩表示：对于稀疏矩阵，对角线元素通常具有特殊的存储方式，因为它们是矩阵中较为密集的部分。</li>
</ul>
<p>使用NumPy的diagonal很容易获取矩阵的对角线元素。 我们还可以使用ffset参数在主对角线的上下偏移， 获取偏移后的对角线方向的元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create matrix</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                   [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>],</span><br><span class="line">                   [<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="comment">#返回对角线元素</span></span><br><span class="line">matrix.diagonal()</span><br><span class="line"><span class="comment"># array([1, 4, 9])</span></span><br><span class="line"><span class="comment"># 返回主对角线上偏移量为1的对角线元素</span></span><br><span class="line">matrix.diagonal(offset=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># array([2, 6])</span></span><br><span class="line"><span class="comment"># 返回主对角线下方偏移量为1的对角线元素</span></span><br><span class="line">matrix.diagonal(offset=-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># array([2, 8])</span></span><br></pre></td></tr></table></figure>

<h2 id="计算矩阵的迹"><a href="#计算矩阵的迹" class="headerlink" title="计算矩阵的迹"></a><strong>计算矩阵的迹</strong></h2><p>矩阵的迹是其对角线元素之和， 常被用在机器学习方法的底层计算中。给定一个NumPy的多维数组， 使用trace就能计算出它的迹。 我们还可以通过先返回矩阵的对角线元素再对其求和的方式来计算矩阵的迹。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create matrix</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                   [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>],</span><br><span class="line">                   [<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="comment"># 返回迹（对角线之和）</span></span><br><span class="line">matrix.trace()</span><br><span class="line"><span class="comment"># 14</span></span><br><span class="line"><span class="comment"># 返回对角线元素之和</span></span><br><span class="line"><span class="built_in">sum</span>(matrix.diagonal())</span><br></pre></td></tr></table></figure>

<h2 id="计算特征值和特征向量"><a href="#计算特征值和特征向量" class="headerlink" title="计算特征值和特征向量"></a><strong>计算特征值和特征向量</strong></h2><p>矩阵的特征值（Eigenvalue）和特征向量（Eigenvector）是线性代数中的重要概念。</p>
<p>对于一个方阵（即行数等于列数的矩阵）A，其特征值是一个标量 λ，它满足以下方程：A * v &#x3D; λ * v，这里，A是一个方阵，v是一个非零向量，λ是特征值。特征值告诉我们在矩阵A的作用下，向量v只发生了缩放，而没有改变方向。特征值可以是实数或复数。特征向量是与特征值相关联的向量。对于方阵A和对应的特征值λ，特征向量v是一个非零向量，它满足上述方程。特征向量描述了在矩阵作用下，向量v的方向不变，只发生了缩放。</p>
<p>特征值和特征向量在多个领域中有广泛的应用，包括：主成分分析（PCA）—特征值和特征向量用于降维数据集，以便在保留数据的主要变化方向的同时减少维度、机器学习—在机器学习中，特征值和特征向量可用于降维、特征选择和数据变换等任务等方面。</p>
<p>使用NumPy的linalg.eig 能计算出任何方阵的特征值和特征向量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create matrix</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">                   [<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>],</span><br><span class="line">                   [<span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="comment">#计算特征值和特征向量</span></span><br><span class="line">eigenvalues, eigenvectors = np.linalg.eig(matrix)</span><br><span class="line"><span class="comment"># 查看特征值</span></span><br><span class="line">eigenvalues</span><br><span class="line"><span class="comment"># array([ 13.55075847, 0.74003145, -3.29078992])</span></span><br><span class="line"><span class="comment"># 查看特征向量</span></span><br><span class="line">eigenvectors</span><br><span class="line"><span class="comment"># array([[-2.52429940e-01, -9.48683298e-01, -3.38042383e-01],</span></span><br><span class="line"><span class="comment">#        [-5.04859881e-01, -4.50923270e-17, -6.76084766e-01],</span></span><br><span class="line"><span class="comment">#        [-8.25466914e-01,  3.16227766e-01,  6.54703549e-01]])</span></span><br></pre></td></tr></table></figure>

<h2 id="计算点积"><a href="#计算点积" class="headerlink" title="计算点积"></a><strong>计算点积</strong></h2><p>矩阵的点积，也称为矩阵乘法或矩阵内积，是一种矩阵运算，用于将两个矩阵相乘，产生一个新的矩阵。矩阵点积的用处非常广泛，特别是在线性代数、统计学、机器学习和工程领域中。</p>
<p>点积的定义如下：假设有两个矩阵A和B，如果A的列数等于B的行数，则可以计算它们的点积。点积的结果矩阵C的元素c_ij等于A的第i行与B的第j列对应元素的乘积之和。具体表达式如下：C &#x3D; A × B，其中，C是结果矩阵，A和B是要相乘的矩阵。</p>
<p>点积的用处包括：</p>
<ul>
<li>线性代数：矩阵点积在线性代数中是一项基本操作。它可以用来解线性方程组、求解特征值和特征向量、计算矩阵的逆等。</li>
<li>数据变换：在统计学和数据分析中，矩阵点积用于数据的变换和降维。例如，主成分分析（PCA）就是通过计算数据协方差矩阵的特征向量和特征值来实现的。</li>
<li>神经网络：在神经网络和深度学习中，矩阵点积是神经网络层之间的主要运算。神经网络的前向传播和反向传播都依赖于矩阵点积来计算权重和激活值之间的关系。</li>
<li>图像处理：在图像处理中，卷积操作通常涉及矩阵点积，用于图像滤波和特征提取。</li>
<li>工程和物理学：矩阵点积在工程和物理学中用于描述复杂的物理系统，如电路分析、机械系统建模等。</li>
</ul>
<p>可以使用NumPy的dot来计算点积， 或者在ython 3.5以上的版本中使用新操作符@计算点积。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立两个向量</span></span><br><span class="line">vector_a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">vector_b = np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="comment"># 计算点积</span></span><br><span class="line">np.dot(vector_a, vector_b)</span><br><span class="line"><span class="comment"># 32</span></span><br></pre></td></tr></table></figure>

<h2 id="矩阵的相加或相减"><a href="#矩阵的相加或相减" class="headerlink" title="矩阵的相加或相减"></a><strong>矩阵的相加或相减</strong></h2><p>使用NumPy的add和subtract函数可以实现矩阵的加减。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立矩阵</span></span><br><span class="line">matrix_a = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                     [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                     [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="comment"># 建立矩阵</span></span><br><span class="line">matrix_b = np.array([[<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">                     [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">                     [<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>]])</span><br><span class="line"><span class="comment"># 两个矩阵相加</span></span><br><span class="line">np.add(matrix_a, matrix_b)</span><br><span class="line"><span class="comment"># array([[ 2,  4,  2],</span></span><br><span class="line"><span class="comment">#        [ 2,  4,  2],</span></span><br><span class="line"><span class="comment">#        [ 2,  4, 10]])</span></span><br><span class="line"><span class="comment"># 两个矩阵相减</span></span><br><span class="line">np.subtract(matrix_a, matrix_b)</span><br><span class="line"><span class="comment"># array([[ 0, -2,  0],</span></span><br><span class="line"><span class="comment">#        [ 0, -2,  0],</span></span><br><span class="line"><span class="comment">#        [ 0, -2, -6]])</span></span><br><span class="line"><span class="comment"># 两个矩阵相加</span></span><br></pre></td></tr></table></figure>

<p>当然，也可以直接使用+或-号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matrix_a + matrix_b</span><br></pre></td></tr></table></figure>

<h2 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a><strong>矩阵的乘法</strong></h2><p>使用NumPy的dot或者在Python 3.5以上的版本中使用“@”操作符可以实现矩阵的乘法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create matrix</span></span><br><span class="line">matrix_a = np.array([[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                     [<span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="comment"># Create matrix</span></span><br><span class="line">matrix_b = np.array([[<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">                     [<span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="comment"># M两个矩阵相乘</span></span><br><span class="line">np.dot(matrix_a, matrix_b)</span><br><span class="line"><span class="comment"># array([[2, 5],</span></span><br><span class="line"><span class="comment">#        [3, 7]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用@实现两个矩阵相乘</span></span><br><span class="line">matrix_a @ matrix_b</span><br></pre></td></tr></table></figure>

<p>如要要将两个矩阵对应的元素相乘，则需要使用*</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 两个矩阵对应的元素相乘</span></span><br><span class="line">matrix_a * matrix_b</span><br><span class="line"><span class="comment"># array([[1, 3],</span></span><br><span class="line"><span class="comment">#        [1, 4]])</span></span><br></pre></td></tr></table></figure>

<h2 id="计算矩阵的逆"><a href="#计算矩阵的逆" class="headerlink" title="计算矩阵的逆"></a><strong>计算矩阵的逆</strong></h2><p>矩阵的逆是矩阵的一种特殊性质，它通常用于解线性方程组和进行线性变换的逆操作。</p>
<p>对于一个方阵（即行数和列数相等的矩阵）A，如果存在另一个方阵B，使得它们的乘积为单位矩阵（记作I），即A乘以B等于I，那么矩阵B就被称为矩阵A的逆，通常表示为A的负一次方（A⁻¹），表示如下：A * A⁻¹ &#x3D; A⁻¹ * A &#x3D; I，其中，A表示原始矩阵，A⁻¹表示它的逆矩阵，I表示单位矩阵。</p>
<p>使用NumPy中的线性代数方法inv可以计算一个矩阵的逆。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create matrix</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">                   [<span class="number">2</span>, <span class="number">5</span>]])</span><br><span class="line"><span class="comment"># 计算矩阵的逆</span></span><br><span class="line">np.linalg.inv(matrix)</span><br><span class="line"><span class="comment"># array([[-1.66666667, 1.33333333],</span></span><br><span class="line"><span class="comment">#        [ 0.66666667, -0.33333333]])</span></span><br><span class="line"><span class="comment"># 矩阵和矩阵的逆相乘</span></span><br><span class="line">matrix @ np.linalg.inv(matrix)</span><br><span class="line"><span class="comment"># array([[ 1., 0.],</span></span><br><span class="line"><span class="comment">#        [ 0., 1.]])</span></span><br></pre></td></tr></table></figure>

<h2 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a><strong>生成随机数</strong></h2><p>使用NumPy的random函数可以生成随机数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置随机种子</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 生成3个0-1之间的浮点数</span></span><br><span class="line">np.random.random(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># array([0.5488135 , 0.71518937, 0.60276338])</span></span><br><span class="line"><span class="comment"># 产生3个3-10之间的随机整数</span></span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">11</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># array([3, 7, 9])</span></span><br><span class="line"><span class="comment"># 从均值是0且标准差是1的正态分布数据中随机抽取3个数</span></span><br><span class="line">np.random.normal(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># array([-1.42232584,  1.52006949, -0.29139398])</span></span><br><span class="line"><span class="comment"># 从均值为0且散布程度是1的逻辑分布中随机抽取3个数</span></span><br><span class="line">np.random.logistic(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># array([-0.98118713, -0.08939902,  1.46416405])</span></span><br><span class="line"><span class="comment"># 从大于或等于1且小于2的数中随机抽取3个数</span></span><br><span class="line">np.random.uniform(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># array([ 1.47997717, 1.3927848 , 1.83607876])</span></span><br></pre></td></tr></table></figure>

<h1 id="Python中的数据整理"><a href="#Python中的数据整理" class="headerlink" title="Python中的数据整理"></a><strong>Python中的数据整理</strong></h1><p>数据整理在数据分析中至关重要。在Python中进行数据整理通常包括数据清洗、转换和重塑。数据整理的思路主要包括以下：</p>
<ol>
<li>数据清洗：</li>
</ol>
<p>处理缺失数据：使用Pandas库的<code>dropna()</code>、<code>fillna()</code>等方法来处理缺失数据。</p>
<p>处理异常值：通过定义阈值或使用统计方法来检测和处理异常值。</p>
<p>处理重复数据：使用Pandas的<code>duplicated()</code>和<code>drop_duplicates()</code>来处理重复数据。</p>
<p>格式规范化：将数据类型转换为合适的格式，如日期时间或数字类型。</p>
<ol start="2">
<li>数据转换：</li>
</ol>
<p>列选择：使用Pandas的<code>df[&#39;column_name&#39;]</code>来选择特定列。</p>
<p>列重命名：使用<code>df.rename(columns=&#123;&#39;old_name&#39;: &#39;new_name&#39;&#125;)</code>来重命名列。</p>
<p>数据类型转换：使用<code>astype()</code>方法将列的数据类型更改为合适的类型。</p>
<p>文本数据处理：使用字符串方法（如<code>str.strip()</code>、<code>str.lower()</code>）处理文本列。</p>
<p>分组和聚合：使用Pandas的<code>groupby()</code>和聚合函数（如<code>sum()</code>、<code>mean()</code>）对数据进行分组和汇总。</p>
<ol start="3">
<li>数据重塑：</li>
</ol>
<p>透视表：使用Pandas的<code>pivot_table()</code>或<code>pivot()</code>来创建透视表。</p>
<p>堆叠和解堆叠：使用<code>stack()</code>和<code>unstack()</code>来重塑数据框。</p>
<p>合并数据：使用<code>merge()</code>或<code>concat()</code>来合并多个数据框。</p>
<p>长格式转宽格式和反之：使用<code>melt()</code>和<code>pivot()</code>来在长格式和宽格式之间进行转换。</p>
<ol start="4">
<li><p>数据可视化：使用Matplotlib、Seaborn或其他数据可视化库来探索数据，识别模式和趋势。绘制直方图、箱线图、散点图等来了解数据分布和相关性。</p>
</li>
<li><p>自定义函数：创建自定义函数来处理特定数据整理需求，例如基于条件的数据清洗、文本提取等。</p>
</li>
<li><p>数据管道：使用Pandas管道（<code>pipe</code>）来构建数据整理工作流，使代码更整洁和可维护。</p>
</li>
<li><p>数据保存：使用<code>to_csv()</code>、<code>to_excel()</code>等方法将整理后的数据保存到文件，以备后续分析或分享。</p>
</li>
</ol>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>“数据整理（data wrangling） ”是一个被广泛使用的词， 经常用于描述将原始数据转换成整洁的、 组织合理的形式以供使用的过程。对于我们而言， 数据整理只是数据预处理中的一个步骤， 但它是一个重要的步骤。在“整理”数据时， 最常用的数据结构是数据帧（data frame） ， 它既直观又灵活。数据帧是呈表格状的， 也就是说， 就像你在数据表中看到的数据一样， 数据帧是用行和列来表示数据的。下面给出一个用泰坦尼克号乘客的数据创建的数据帧：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load library</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># Create URL</span></span><br><span class="line">url = <span class="string">&#x27;https://raw.githubusercontent.com/chrisalbon/simulated_datasets/master/titanic.csv&#x27;</span></span><br><span class="line"><span class="comment"># 将数据加载为数据框</span></span><br><span class="line">dataframe = pd.read_csv(url)</span><br><span class="line"><span class="comment"># 展示前五行</span></span><br><span class="line">dataframe.head(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># Out[16]: </span></span><br><span class="line"><span class="comment">#                                             Name PClass  ...  Survived SexCode</span></span><br><span class="line"><span class="comment"># 0                   Allen, Miss Elisabeth Walton    1st  ...         1       1</span></span><br><span class="line"><span class="comment"># 1                    Allison, Miss Helen Loraine    1st  ...         0       1</span></span><br><span class="line"><span class="comment"># 2            Allison, Mr Hudson Joshua Creighton    1st  ...         0       0</span></span><br><span class="line"><span class="comment"># 3  Allison, Mrs Hudson JC (Bessie Waldo Daniels)    1st  ...         0       1</span></span><br><span class="line"><span class="comment"># 4                  Allison, Master Hudson Trevor    1st  ...         1       0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [5 rows x 6 columns]</span></span><br></pre></td></tr></table></figure>

<p>在这个数据帧中有三件重要的事情需要注意。第一， 在一个数据帧中， 每一行都对应一个观察值（例如， 一位乘客） ， 每一列都对应一个特征（性别、 年龄等） 。举个例子， 通过查看第一个观察值可知， Elisabeth Walton Allen小姐住在头等舱， 当年29， 在灾难中活了下来。第二， 每一列有一个数据头（例如， Name、 PClass、 Age） ， 每一行有一个索引（例如， 这位幸运的Elisabeth Walton Allen小姐的索引号是0） 。这些数据能用于选择及操作观察值与特征。第三， Sex和SexCode这两列虽然用的是不同的表现形式， 但是包含了同样的信息。在Sex列中， 女性用字符串female表示， 而在SexCode列中，女性用整数1表示。如果想让所有的特征都是唯一的， 需要删除这两列中的一列。在本章中， 为了创建一组整洁、 组织合理的观察值以供接下来的预处理之用， 我们会调用pandas库， 使用各种不同的方法来操作数据帧。</p>
<h2 id="创建一个数据帧"><a href="#创建一个数据帧" class="headerlink" title="创建一个数据帧"></a><strong>创建一个数据帧</strong></h2><p>在pandas中有很多方法可以创建一个新的数据帧对象。一个简单的方法是， 使用DataFrame创建一个空数据帧并分别定义好每一列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.1 创建一个数据帧</span></span><br><span class="line"><span class="comment"># 创建数据框</span></span><br><span class="line">dataframe = pd.DataFrame()</span><br><span class="line"><span class="comment"># 添加列</span></span><br><span class="line">dataframe[<span class="string">&#x27;Name&#x27;</span>] = [<span class="string">&#x27;Jacky Jackson&#x27;</span>, <span class="string">&#x27;Steven Stevenson&#x27;</span>]</span><br><span class="line">dataframe[<span class="string">&#x27;Age&#x27;</span>] = [<span class="number">38</span>, <span class="number">25</span>]</span><br><span class="line">dataframe[<span class="string">&#x27;Driver&#x27;</span>] = [<span class="literal">True</span>, <span class="literal">False</span>]</span><br><span class="line"><span class="comment"># 展示数据框</span></span><br><span class="line">dataframe</span><br><span class="line"><span class="comment"># Out[23]: </span></span><br><span class="line"><span class="comment">#                Name  Age  Driver</span></span><br><span class="line"><span class="comment"># 0     Jacky Jackson   38    True</span></span><br><span class="line"><span class="comment"># 1  Steven Stevenson   25   False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建行</span></span><br><span class="line">new_person = pd.Series([<span class="string">&#x27;Molly Mooney&#x27;</span>, <span class="number">40</span>, <span class="literal">True</span>], index=[<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>,<span class="string">&#x27;Driver&#x27;</span>])</span><br><span class="line"><span class="comment"># 添加行</span></span><br><span class="line">dataframe.append(new_person, ignore_index=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># Out[25]: </span></span><br><span class="line"><span class="comment">#                Name  Age  Driver</span></span><br><span class="line"><span class="comment"># 0     Jacky Jackson   38    True</span></span><br><span class="line"><span class="comment"># 1  Steven Stevenson   25   False</span></span><br><span class="line"><span class="comment"># 2      Molly Mooney   40    True</span></span><br></pre></td></tr></table></figure>

<p>虽然pandas提供了无数方法来创建数据帧， 但是在真实场景中， 创建一个空的数据帧对象然后再填充数据的情况几乎不会发生。相反， 我们将通过加载自其他源（例如， 一个CSV文件或数据库） 的真实数据创建数据帧。</p>
<h2 id="描述数据"><a href="#描述数据" class="headerlink" title="描述数据"></a><strong>描述数据</strong></h2><p>在加载完数据之后， 我们能做的最简单的事之一就是使用head查看前几行数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">dataframe = pd.read_csv(url)</span><br><span class="line"><span class="comment"># 展示前两行</span></span><br><span class="line">dataframe.head(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Out[27]: </span></span><br><span class="line"><span class="comment">#                            Name PClass   Age     Sex  Survived  SexCode</span></span><br><span class="line"><span class="comment"># 0  Allen, Miss Elisabeth Walton    1st  29.0  female         1        1</span></span><br><span class="line"><span class="comment"># 1   Allison, Miss Helen Loraine    1st   2.0  female         0        1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示数据维度</span></span><br><span class="line">dataframe.shape</span><br><span class="line"><span class="comment"># Out[28]: (1313, 6)</span></span><br></pre></td></tr></table></figure>

<p>或者， 也可以使用describe来获取任何数值型列的描述性统计量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 展示描述性统计结果</span></span><br><span class="line">dataframe.describe()</span><br><span class="line"><span class="comment"># Out[30]: </span></span><br><span class="line"><span class="comment">#               Age     Survived      SexCode</span></span><br><span class="line"><span class="comment"># count  756.000000  1313.000000  1313.000000</span></span><br><span class="line"><span class="comment"># mean    30.397989     0.342727     0.351866</span></span><br><span class="line"><span class="comment"># std     14.259049     0.474802     0.477734</span></span><br><span class="line"><span class="comment"># min      0.170000     0.000000     0.000000</span></span><br><span class="line"><span class="comment"># 25%     21.000000     0.000000     0.000000</span></span><br><span class="line"><span class="comment"># 50%     28.000000     0.000000     0.000000</span></span><br><span class="line"><span class="comment"># 75%     39.000000     1.000000     1.000000</span></span><br><span class="line"><span class="comment"># max     71.000000     1.000000     1.000000</span></span><br></pre></td></tr></table></figure>

<p>加载数据后， 最好了解一下它的结构以及包含了什么类型的信息。理想的情况是直接查看全部数据。但是在现实中， 很多情况下数据都会包含成千上万的行和列。这时， 我们可以选取一些样本来查看一小部分数据， 也可以利用样本来计算数据的描述性统计量。</p>
<p>在上述解决方案中， 我们用到了由泰坦尼克号的乘客记录组成的玩具数据集。使用head可以查看数据集的前几行（默认查看前5行） ， 使用tail可以查看最后几行；使用shape可以查看数据帧中包含了多少行和多少列；最后， 使用describe能查看任何数值型的列的基本描述性统计量。</p>
<p>值得注意的是， 描述性统计量并不一定能全面反映数据的情况。例如，pandas将Survived和SexCode视为数值型的列， 因为它们包含了很多0和1。然而， 在本例中， 数值型的值代表的是分类（例如， 如果Survived等于1， 就表示乘客在此次海难中幸存） 。由于这个原因， 一些描述性统计量， 比如SexCode（代表乘客的性别） 列的标准差， 不能提供很直观的结论。</p>
<h2 id="浏览数据帧"><a href="#浏览数据帧" class="headerlink" title="浏览数据帧"></a><strong>浏览数据帧</strong></h2><p>使用loc或iloc能选择一个或多个数据， 也能选择一行或多行数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择第一行</span></span><br><span class="line">dataframe.iloc[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># Out[31]: </span></span><br><span class="line"><span class="comment"># Name        Allen, Miss Elisabeth Walton</span></span><br><span class="line"><span class="comment"># PClass                               1st</span></span><br><span class="line"><span class="comment"># Age                                 29.0</span></span><br><span class="line"><span class="comment"># Sex                               female</span></span><br><span class="line"><span class="comment"># Survived                               1</span></span><br><span class="line"><span class="comment"># SexCode                                1</span></span><br><span class="line"><span class="comment"># Name: 0, dtype: object</span></span><br><span class="line"><span class="comment"># 可以使用冒号“: ”来定义想要选择哪些行。比如选择第2、 3、 4行：</span></span><br><span class="line"><span class="comment"># 选择3行</span></span><br><span class="line">dataframe.iloc[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="comment"># Out[32]: </span></span><br><span class="line"><span class="comment">#                                             Name PClass  ...  Survived SexCode</span></span><br><span class="line"><span class="comment"># 1                    Allison, Miss Helen Loraine    1st  ...         0       1</span></span><br><span class="line"><span class="comment"># 2            Allison, Mr Hudson Joshua Creighton    1st  ...         0       0</span></span><br><span class="line"><span class="comment"># 3  Allison, Mrs Hudson JC (Bessie Waldo Daniels)    1st  ...         0       1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择前4行</span></span><br><span class="line">dataframe.iloc[:<span class="number">4</span>]</span><br><span class="line"><span class="comment"># Out[33]: </span></span><br><span class="line"><span class="comment">#                                             Name PClass  ...  Survived SexCode</span></span><br><span class="line"><span class="comment"># 0                   Allen, Miss Elisabeth Walton    1st  ...         1       1</span></span><br><span class="line"><span class="comment"># 1                    Allison, Miss Helen Loraine    1st  ...         0       1</span></span><br><span class="line"><span class="comment"># 2            Allison, Mr Hudson Joshua Creighton    1st  ...         0       0</span></span><br><span class="line"><span class="comment"># 3  Allison, Mrs Hudson JC (Bessie Waldo Daniels)    1st  ...         0       1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [4 rows x 6 columns]</span></span><br></pre></td></tr></table></figure>

<p>数据帧的索引不必非得是数值型。只要某一列在数据帧中每一行的值是唯一的， 就可以将其设置为索引。举个例子， 我们可以将乘客的名字设置为索引， 然后通过名字来选择行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置索引</span></span><br><span class="line">dataframe = dataframe.set_index(dataframe[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"><span class="comment"># 展示行</span></span><br><span class="line">dataframe.loc[<span class="string">&#x27;Allen, Miss Elisabeth Walton&#x27;</span>]</span><br><span class="line"><span class="comment"># Out[35]: </span></span><br><span class="line"><span class="comment"># Name        Allen, Miss Elisabeth Walton</span></span><br><span class="line"><span class="comment"># PClass                               1st</span></span><br><span class="line"><span class="comment"># Age                                 29.0</span></span><br><span class="line"><span class="comment"># Sex                               female</span></span><br><span class="line"><span class="comment"># Survived                               1</span></span><br><span class="line"><span class="comment"># SexCode                                1</span></span><br><span class="line"><span class="comment"># Name: Allen, Miss Elisabeth Walton, dtype: object</span></span><br></pre></td></tr></table></figure>

<p>pandas的数据帧中所有的行都会有一个唯一的索引值。默认情况下， 这个索引是一个整数， 它标明了这一行在数据帧中的行的位置。然而， 索引不一定必须是这样的一个整数。数据帧的索引可以被设置成一个唯一的字母与数字组成的字符串或自定义数字。为了能选择一行或者部分行， pandas提供了两个方法：<br>● 当数据帧的索引是一个标签时（例如， 一个字符串） ,loc比较常用。<br>● iloc并不是根据索引来查找数据的， 而是根据行号来查找的， 行号从0开始， 逐次加1。举个例子， 不管索引是一个整数还是一个标签， iloc[0]都将返回第1行的数据。</p>
<p>由于在数据清洗时会频繁使用loc和iloc， 所以有必要熟悉它们。</p>
<h2 id="根据条件语句来选择行"><a href="#根据条件语句来选择行" class="headerlink" title="根据条件语句来选择行"></a><strong>根据条件语句来选择行</strong></h2><p>利用pandas可以根据某个条件语句来选择数据帧的行数据。例如， 选择泰坦尼克号上所有女性乘客的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">dataframe = pd.read_csv(url)</span><br><span class="line"><span class="comment"># 展示前两行中性别是女性的观测值</span></span><br><span class="line">dataframe[dataframe[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;female&#x27;</span>].head(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Out[38]: </span></span><br><span class="line"><span class="comment">#                            Name PClass   Age     Sex  Survived  SexCode</span></span><br><span class="line"><span class="comment"># 0  Allen, Miss Elisabeth Walton    1st  29.0  female         1        1</span></span><br><span class="line"><span class="comment"># 1   Allison, Miss Helen Loraine    1st   2.0  female         0        1</span></span><br><span class="line"><span class="comment"># 要同时使用多个条件语句也很简单。 下面的代码就筛选出了所有年龄大于或等于65岁的女性乘客的行数据：</span></span><br><span class="line"><span class="comment"># 筛选行</span></span><br><span class="line">dataframe[(dataframe[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;female&#x27;</span>) &amp; (dataframe[<span class="string">&#x27;Age&#x27;</span>] &gt;= <span class="number">65</span>)]</span><br><span class="line"><span class="comment"># Out[39]: </span></span><br><span class="line"><span class="comment">#                                                  Name PClass  ...  Survived SexCode</span></span><br><span class="line"><span class="comment"># 73  Crosby, Mrs Edward Gifford (Catherine Elizabet...    1st  ...         1       1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [1 rows x 6 columns]</span></span><br></pre></td></tr></table></figure>

<p>dataframe[‘Sex’] &#x3D;&#x3D; ‘female’就是条件语句。我们在它的外面包了一层dataframe[]来告诉pandas:“选择数据帧中所有dataFrame[‘Sex’]的值是’female’的行数据”。当然，在上面的代码中我们也可以设置多个条件</p>
<h2 id="替换值"><a href="#替换值" class="headerlink" title="替换值"></a><strong>替换值</strong></h2><p>用pandas的replace方法能很容易地找到并替换一些值。例如， 用＂Woman＂ 来替换Sex列中所有的＂ female＂ ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">dataframe = pd.read_csv(url)</span><br><span class="line"><span class="comment"># 替换值展示前两行</span></span><br><span class="line">dataframe[<span class="string">&#x27;Sex&#x27;</span>].replace(<span class="string">&quot;female&quot;</span>, <span class="string">&quot;Woman&quot;</span>).head(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 0    Woman</span></span><br><span class="line"><span class="comment"># 1    Woman</span></span><br><span class="line"><span class="comment"># Name: Sex, dtype: object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然， 我们也能同时替换多个值：</span></span><br><span class="line"><span class="comment"># 将&quot;female&quot; 和 &quot;male 替换为 &quot;Woman&quot; 和 &quot;Man&quot;</span></span><br><span class="line">dataframe[<span class="string">&#x27;Sex&#x27;</span>].replace([<span class="string">&quot;female&quot;</span>, <span class="string">&quot;male&quot;</span>], [<span class="string">&quot;Woman&quot;</span>, <span class="string">&quot;Man&quot;</span>]).head(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># Out[47]: </span></span><br><span class="line"><span class="comment"># 0    Woman</span></span><br><span class="line"><span class="comment"># 1    Woman</span></span><br><span class="line"><span class="comment"># 2      Man</span></span><br><span class="line"><span class="comment"># 3    Woman</span></span><br><span class="line"><span class="comment"># 4      Man</span></span><br><span class="line"><span class="comment"># Name: Sex, dtype: object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过Dataframe对象在整个数据帧中查找和替换值， 而不仅限于在单个列中查找和替换值：</span></span><br><span class="line"><span class="comment"># 替换值，展示前两行</span></span><br><span class="line">dataframe.replace(<span class="number">1</span>, <span class="string">&quot;One&quot;</span>).head(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Out[48]: </span></span><br><span class="line"><span class="comment">#                            Name PClass   Age     Sex Survived SexCode</span></span><br><span class="line"><span class="comment"># 0  Allen, Miss Elisabeth Walton    1st  29.0  female      One     One</span></span><br><span class="line"><span class="comment"># 1   Allison, Miss Helen Loraine    1st   2.0  female        0     One</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换也支持正则表达式</span></span><br><span class="line"><span class="comment"># 替换值，显示前两行</span></span><br><span class="line">dataframe.replace(<span class="string">r&quot;1st&quot;</span>, <span class="string">&quot;First&quot;</span>, regex=<span class="literal">True</span>).head(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Out[49]: </span></span><br><span class="line"><span class="comment">#                            Name PClass   Age     Sex  Survived  SexCode</span></span><br><span class="line"><span class="comment"># 0  Allen, Miss Elisabeth Walton  First  29.0  female         1        1</span></span><br><span class="line"><span class="comment"># 1   Allison, Miss Helen Loraine  First   2.0  female         0        1</span></span><br></pre></td></tr></table></figure>

<p>replace是一个用来做值替换的工具， 很简单， 而且它还接受正则表达式， 所以它的功能其实很强大。</p>
<h2 id="重命名列"><a href="#重命名列" class="headerlink" title="重命名列"></a><strong>重命名列</strong></h2><p>用rename方法可以实现重命名列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">dataframe = pd.read_csv(url)</span><br><span class="line"><span class="comment"># 列名重命名显示前两行</span></span><br><span class="line">dataframe.rename(columns=&#123;<span class="string">&#x27;PClass&#x27;</span>: <span class="string">&#x27;Passenger Class&#x27;</span>&#125;).head(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Out[40]: </span></span><br><span class="line"><span class="comment">#                            Name Passenger Class  ...  Survived SexCode</span></span><br><span class="line"><span class="comment"># 0  Allen, Miss Elisabeth Walton             1st  ...         1       1</span></span><br><span class="line"><span class="comment"># 1   Allison, Miss Helen Loraine             1st  ...         0       1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [2 rows x 6 columns]</span></span><br></pre></td></tr></table></figure>

<p>rename方法可以传入一个字典作为参数。用字典可以同时改变多个列名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataframe.rename(columns=&#123;<span class="string">&#x27;PClass&#x27;</span>: <span class="string">&#x27;Passenger Class&#x27;</span>, <span class="string">&#x27;Sex&#x27;</span>: <span class="string">&#x27;Gender&#x27;</span>&#125;).head(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Out[44]: </span></span><br><span class="line"><span class="comment">#                            Name Passenger Class  ...  Survived SexCode</span></span><br><span class="line"><span class="comment"># 0  Allen, Miss Elisabeth Walton             1st  ...         1       1</span></span><br><span class="line"><span class="comment"># 1   Allison, Miss Helen Loraine             1st  ...         0       1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [2 rows x 6 columns]</span></span><br></pre></td></tr></table></figure>

<p>以字典作为columns参数使用rename来重命名列是比较推荐的方法， 因为它能同时为多个列重命名。如果想同时为所有的列重命名， 下面这一小段代码会很有用。它以旧列名为键、 空字符串为值， 创建了一个字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载库</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="comment"># 创建字典</span></span><br><span class="line">column_names = collections.defaultdict(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># 创建键</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> dataframe.columns:column_names[name]</span><br><span class="line"><span class="comment"># 展示自定</span></span><br><span class="line">column_names</span><br><span class="line"><span class="comment"># Out[53]: </span></span><br><span class="line"><span class="comment"># defaultdict(str,</span></span><br><span class="line"><span class="comment">#             &#123;&#x27;Name&#x27;: &#x27;&#x27;,</span></span><br><span class="line"><span class="comment">#              &#x27;PClass&#x27;: &#x27;&#x27;,</span></span><br><span class="line"><span class="comment">#              &#x27;Age&#x27;: &#x27;&#x27;,</span></span><br><span class="line"><span class="comment">#              &#x27;Sex&#x27;: &#x27;&#x27;,</span></span><br><span class="line"><span class="comment">#              &#x27;Survived&#x27;: &#x27;&#x27;,</span></span><br><span class="line"><span class="comment">#              &#x27;SexCode&#x27;: &#x27;&#x27;&#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="计算最小值、-最大值、-总和、-平均值与计数值"><a href="#计算最小值、-最大值、-总和、-平均值与计数值" class="headerlink" title="计算最小值、 最大值、 总和、 平均值与计数值"></a><strong>计算最小值、 最大值、 总和、 平均值与计数值</strong></h2><p>pandas提供了一些内置的方法来计算常见的描述性统计量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">dataframe = pd.read_csv(url)</span><br><span class="line"><span class="comment"># 计算统计量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Maximum:&#x27;</span>, dataframe[<span class="string">&#x27;Age&#x27;</span>].<span class="built_in">max</span>())</span><br><span class="line"><span class="comment"># Maximum: 71.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Minimum:&#x27;</span>, dataframe[<span class="string">&#x27;Age&#x27;</span>].<span class="built_in">min</span>())</span><br><span class="line"><span class="comment"># Minimum: 0.17</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Mean:&#x27;</span>, dataframe[<span class="string">&#x27;Age&#x27;</span>].mean())</span><br><span class="line"><span class="comment"># Mean: 30.397989417989415</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Sum:&#x27;</span>, dataframe[<span class="string">&#x27;Age&#x27;</span>].<span class="built_in">sum</span>())</span><br><span class="line"><span class="comment"># Sum: 22980.88</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Count:&#x27;</span>, dataframe[<span class="string">&#x27;Age&#x27;</span>].count())</span><br><span class="line"><span class="comment"># Count: 756</span></span><br></pre></td></tr></table></figure>

<p>除了解决方案中用到的描述性统计量， pandas还提供了计算方差（var） 、 标准差（std） 、 峰态（kurt） 、 偏态（skew） 、 平均值标准误差（sem） 、 众数（mode） 、 中位数（median） 以及很多其他描述性统计量的方法。<br>此外， 也可以对整个数据帧应用这些方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看计数</span></span><br><span class="line">dataframe.count()</span><br><span class="line"><span class="comment"># Name        1313</span></span><br><span class="line"><span class="comment"># PClass      1313</span></span><br><span class="line"><span class="comment"># Age          756</span></span><br><span class="line"><span class="comment"># Sex         1313</span></span><br><span class="line"><span class="comment"># Survived    1313</span></span><br><span class="line"><span class="comment"># SexCode     1313</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br></pre></td></tr></table></figure>

<h2 id="查找唯一值"><a href="#查找唯一值" class="headerlink" title="查找唯一值"></a><strong>查找唯一值</strong></h2><p>使用unique可以来查看由某一列中全部的唯一值组成的数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataframe = pd.read_csv(url)</span><br><span class="line"><span class="comment"># 选择唯一值</span></span><br><span class="line">dataframe[<span class="string">&#x27;Sex&#x27;</span>].unique()</span><br><span class="line"><span class="comment"># Out[63]: array([&#x27;female&#x27;, &#x27;male&#x27;], dtype=object)</span></span><br><span class="line"><span class="comment"># 还可以使用value_counts， 它会显示所有的唯一值以及它们出现的次数：</span></span><br><span class="line"><span class="comment"># 展示计数</span></span><br><span class="line">dataframe[<span class="string">&#x27;Sex&#x27;</span>].value_counts()</span><br><span class="line"><span class="comment"># Out[64]: </span></span><br><span class="line"><span class="comment"># male      851</span></span><br><span class="line"><span class="comment"># female    462</span></span><br><span class="line"><span class="comment"># Name: Sex, dtype: int64</span></span><br></pre></td></tr></table></figure>

<p>unique和value_counts都可以用来处理和探索分类型数据的（categorical） 列。在数据整理阶段， 分类型数据的列中经常会有一些分类需要处理。例如， 在泰坦尼克号的数据集中， PClass这个列是用来表示乘客船票级别的。泰坦尼克号中有三种级别的船票， 而如果使用alue_counts， 我们就能看出数据中的一个问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show counts</span></span><br><span class="line">dataframe[<span class="string">&#x27;PClass&#x27;</span>].value_counts()</span><br><span class="line"><span class="comment"># Out[65]: </span></span><br><span class="line"><span class="comment"># 3rd    711</span></span><br><span class="line"><span class="comment"># 1st    322</span></span><br><span class="line"><span class="comment"># 2nd    279</span></span><br><span class="line"><span class="comment"># *        1</span></span><br><span class="line"><span class="comment"># Name: PClass, dtype: int64</span></span><br></pre></td></tr></table></figure>

<p>几乎所有乘客的船票都在这三种级别中， 但有一位乘客的船票级别是*。有很多种策略能处理这种类型的问题， 在后面会详细介绍。现在， 我们只需要认识到“异常”类型的数据在分类型数据中很常见， 不应该忽视它们。如果你只是想统计有多少个唯一值， 则可以使用nunique：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show number of unique values</span></span><br><span class="line">dataframe[<span class="string">&#x27;PClass&#x27;</span>].nunique()</span><br><span class="line"><span class="comment"># Out[66]: 4</span></span><br></pre></td></tr></table></figure>

<h2 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a><strong>处理缺失值</strong></h2><p>isnull和notnull都能返回布尔型的值来表示一个值是否缺失：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">dataframe = pd.read_csv(url)</span><br><span class="line"><span class="comment">## 选择缺失值展示前两行</span></span><br><span class="line">dataframe[dataframe[<span class="string">&#x27;Age&#x27;</span>].isnull()].head(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Out[68]: </span></span><br><span class="line"><span class="comment">#                             Name PClass  Age     Sex  Survived  SexCode</span></span><br><span class="line"><span class="comment"># 12  Aubert, Mrs Leontine Pauline    1st  NaN  female         1        1</span></span><br><span class="line"><span class="comment"># 13      Barkworth, Mr Algernon H    1st  NaN    male         1        0</span></span><br></pre></td></tr></table></figure>

<p>在数据整理中， 缺失值是很常见的问题， 很多人都低估了处理缺失值的难度。pandas使用NumPy的NaN（“Not A Number”， 意为“不是一个数字”） 来表示缺失值。但值得注意的是， pandas没有实现NaN。例如， 如果想要将所有包含male的字符串替换为缺失值的话， 就会得到一条错误消息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 尝试使用NaN替换值</span></span><br><span class="line">dataframe[<span class="string">&#x27;Sex&#x27;</span>] = dataframe[<span class="string">&#x27;Sex&#x27;</span>].replace(<span class="string">&#x27;male&#x27;</span>, NaN)</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   File &quot;C:\Users\Aimin Jiang\AppData\Local\Temp\ipykernel_151784\15800115.py&quot;, line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     dataframe[&#x27;Sex&#x27;] = dataframe[&#x27;Sex&#x27;].replace(&#x27;male&#x27;, NaN)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NameError: name &#x27;NaN&#x27; is not defined</span></span><br></pre></td></tr></table></figure>

<p>要想使用NaN就需要先导入NumPy库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 使用NaN替换值</span></span><br><span class="line">dataframe[<span class="string">&#x27;Sex&#x27;</span>] = dataframe[<span class="string">&#x27;Sex&#x27;</span>].replace(<span class="string">&#x27;male&#x27;</span>, np.nan)</span><br></pre></td></tr></table></figure>

<p>有时候一个数据集会使用特殊的值来表示缺失的观察值， 比如NONE、 -999或者． 。pandas的read_csv中有一个参数， 允许用户指定一个值来代表缺失值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据设置缺失值</span></span><br><span class="line">dataframe = pd.read_csv(url, na_values=[np.nan, <span class="string">&#x27;NONE&#x27;</span>, -<span class="number">999</span>])</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>参考来源：</strong></p>
<p>Chris Albon，Machine Learning with Python Cookbook-Practical Solutions from Preprocessing to Deep Learning</p>
]]></content>
      <categories>
        <category>Python与机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>临床预测模型|预测研究中的验证问题：应该废除队列拆分？</title>
    <url>/year/022133039.html</url>
    <content><![CDATA[<p>临床预测模型的验证问题一直以来是一个大家较为关注的问题。尤其是在缺乏外部验证的情况下。在很多的临床预测模型中，队列拆分随处可见。尤其是在一些小样本研究中，也可以看到作者将数据集随机拆分为训练队列和内部验证队列。尽管是在很多已发表的SCI论文中都能看到这一现象。</p>
<span id="more"></span>

<p>一方面，我们之前谈到过临床预测模型的样本量计算问题。譬如说小样本研究预测模型中基于训练集的多因素回归分析中得到4个回归系数对应有显著统计学差异。而此时，假如整个数据集中有40个患者出现了结局事件，队列拆分后训练集中仅仅有25个患者出现了结局事件。这种情况下还能队列拆分嘛？经验性的做法是10EPV原则。此时用整个数据集来建模更加合理，可以使用交叉验证或者重抽样的方法来对模型进行验证。</p>
<p>偶然看到很早之前Ewout W. Steyerberg发表的关于一篇预测研究中队列拆分的文章。尽管发表时间较早，但是对人还是颇有启发，建议学习下。此外，Ewout W. Steyerberg编写的临床预测模型（第二版）中对于临床预测模型进行了系统的介绍。</p>
<p><img src="https://pic3.zhimg.com/80/v2-12705e7d8d564b4b4289c8c459763726_1440w.webp" alt="Steyerberg, Ewout W. “Validation in prediction research: the waste by data splitting.” Journal of clinical epidemiology vol. 103 (2018): 131-133. doi:10.1016/j.jclinepi.2018.07.010"></p>
<p><img src="https://pic2.zhimg.com/80/v2-076af37b3ece0a8e373e0b09a263aff5_1440w.webp" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-197000f774591d24079d6bcdd6246483_1440w.webp" alt="img"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>精确预测医学结果对于诊断和预后至关重要。如今，主流的医学期刊的标准要求是必须展示预测模型在独立外部验证队列中的有效性。这种数据分割是否是资源浪费的一个例子呢？<strong>在大样本中，关注点应转向评估模型在不同环境中预测性能的异质性。在小样本中，交叉验证和重抽样法是更有效的模型验证方法</strong>。总的来说，应该废除随机数据分割来验证模型的预测性能。</p>
<h2 id="主要发现"><a href="#主要发现" class="headerlink" title="主要发现"></a><strong>主要发现</strong></h2><p>• 在小样本中进行模型的独立验证，例如在仅有3名患者发生了结局事件的样本量为10的小样本队列中，进行模型验证完全是画蛇添足。</p>
<p>• 基于数据模拟的验证表明，至少需要100次事件和100次非事件，才能可靠地评估预测性能。</p>
<p>• 在非常大的样本中，模型整体上的独立验证相对不重要，因为我们应该关注对模型性能在不同环境中的异质性进行评估，而不仅仅是平均水平。</p>
<p>• 在外部验证研究中，预测模型通常表现不佳</p>
<p>• 大多数研究的独立验证通常通过随机分割数据集来进行</p>
<p>• 尽管已知随机拆分数据的验证方式效率低下，但大多数研究仍然按照这种方法进行，反映了对小型和大型样本预测模型验证目标认知的不足</p>
<h2 id="这意味着什么？"><a href="#这意味着什么？" class="headerlink" title="这意味着什么？"></a><strong>这意味着什么？</strong></h2><p>• 应该废除随机数据拆分用于模型的独立炎症。</p>
<p>• 在小样本研究中，我们应该接受小规模预测研究仅具有探索性质的事实。我们应该使用交叉验证和重抽样法作为更有效的方法来评估模型的平均水平预测性能。</p>
<p>• 在大样本研究中，应该评估模型性能在不同环境中的异质性。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h2><p>目前，医学诊断和预后模型的研究越来越多。我们也越来越意识到，在外部验证研究中，许多预测模型的表现性能较差。针对这一问题，如今主流的医学期刊的标准要求是必须展示预测模型在独立的外部验证队列中的有效性。研究人员通常会将数据集随机拆分为开发（或训练）队列和验证（或测试）队列。然而，我们看到不管是小样本研究还是大样本研究中都存在这种做法。这种数据分割是对资源的浪费嘛？</p>
<h3 id="大样本验证"><a href="#大样本验证" class="headerlink" title="大样本验证"></a><strong>大样本验证</strong></h3><p>几乎所有来自 QResearch 一般实践的预测模型中都可以找到用于开发和验证的大样本示例，从而产生 Q 评分算法。这可以看作是大数据方法。在这里，来自数百个普通诊所的例行收集数据用于模型开发，数百个用于验证。这种样本分割的方法因其提供独立、因此无偏的模型性能评估而具有吸引力。其主要缺点是这种样本拆分验证是低效的。如果样本量非常庞大，我们就不需要这种数据拆分的验证方法来估计模型的平均性能。在数据模拟中，当事件数量超过100,000个且预测因子少于100个的情况下，模型的平均预测性能的提升可以忽略不计。这种情况下，应该考虑使用随机效应建模或内部-外部验证的方法来评估模型的性能。上述方法中用来开发模型的数据集中的部分数据被迭代地排除。因此，这种分析方法可以量化模型预测性能的异质性，而不是强调其平均性能。总体而言，有人可能会认为在大数据集中进行样本拆分验证是低效的，但对结果却没有任何影响。另一方面，模型验证通常也会涉及到样本量较小的情况。</p>
<h3 id="小样本验证"><a href="#小样本验证" class="headerlink" title="小样本验证"></a><strong>小样本验证</strong></h3><p>最近一个相当极端的数据分割的例子是在白血病中评估单细胞分析的预测价值的研究。为了预测复发，研究团队在54名白血病患者中开发了一个预测模型（80%的患者用于训练，n &#x3D; 44），并在其余20%的患者中进行验证（n &#x3D; 10）。作者通过C-统计量评估模型的判别能力。研究发现，在验证队列的10名患者中有3例复发，且完全分开：这3例复发发生在“高风险”组中，而在7名“低风险”患者中未发现任何复发。这似乎过于美好以至于难以置信。不必成为理论统计学家也能理解，用3个事件进行验证伴有着巨大的不确定性，这意味着对这种小样本验证需要非常谨慎的解释。有人建议至少需要100个事件来可靠评估预测性能，而其他人建议相对较小的样本量。通过在不同样本量的数据集上进行模拟研究，可以很好地研究模型预测性能评估的不确定性，以检验两个假设：</p>
<p>\1. 用3个事件进行验证完全属于画蛇添足。</p>
<p>\2. 至少使用100个事件进行验证是合理的。</p>
<h3 id="模拟研究"><a href="#模拟研究" class="headerlink" title="模拟研究"></a><strong>模拟研究</strong></h3><p>在这里，作者设计了一项模拟研究，设置了以下3个不同样本大小的数据集，但是每个数据集中都有30%的事件发生率（类似于白血病研究）：极小样本（10名患者，3个事件）、中等样本（333名患者，100个事件）、大样本（1667名患者，500个事件）。作者通过模拟检验了3种不同预测模型的变异性，假设预测模型的真实C-统计量为0.7、0.8或0.9。作者发现，仅有3个事件时，相当一部分验证样本被认为会出现结局事件（C&#x3D;1），即在真实C-统计量为0.7、0.8和0.9的验证中分别为6%、15%和35%。另一方面，在真实C-统计量远高于0.5的情况下，预测较差的情况（C&lt;0.5）发生的概率分别为15%、5%和1%。95%CI分别从C&#x3D;0.29、0.43、0.62开始，到C&#x3D;1.0结束。在100个事件的模拟数据集中，真实C为0.7、0.8和0.9的95%范围分别为[0.64-0.76]、[0.75-0.85]、[0.86-0.93]。进一步发现当在500个事件的数据集中时，C的置信区间更小：真实C为0.7、0.8和0.9的95%范围分别为[0.67-0.73]、[0.78-0.82]、[0.88-0.92]。这些结果支持假设1：在10名患者中有3个事件的验证完全属于画蛇添足，即使真实C-统计量为0.7，也有可能出现C&#x3D;1的情况（观察到c&#x3D;1的概率为6%）。关于至少有100个事件的第二个主张更具争议，不确定性仍然相当大，真实值的95%CI在C-统计量的上下0.05范围之间。例如真实C-统计量为0.8时为0.75-0.85。当有500个事件时，可以实现更可靠的评估。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Simulation, May 2018 </span></span><br><span class="line">library<span class="punctuation">(</span>rms<span class="punctuation">)</span> </span><br><span class="line"></span><br><span class="line">i <span class="operator">&lt;-</span> 100000 <span class="comment"># sufficient precision </span></span><br><span class="line">Results  <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span>nrow<span class="operator">=</span>i<span class="punctuation">,</span> ncol<span class="operator">=</span><span class="number">3</span><span class="punctuation">)</span> </span><br><span class="line">set.seed<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>j <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span>i<span class="punctuation">)</span> <span class="punctuation">&#123;</span> <span class="comment"># start simulation </span></span><br><span class="line">  n0 <span class="operator">&lt;-</span> 7 </span><br><span class="line">  n1 <span class="operator">&lt;-</span> 3 </span><br><span class="line">  X0 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n0 <span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span> <span class="comment"># controls, no event </span></span><br><span class="line">  X1.7 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n1 <span class="punctuation">,</span> <span class="number">0.7416145</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span> <span class="comment"># true c = 0.7 </span></span><br><span class="line">  X1.8 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n1 <span class="punctuation">,</span> <span class="number">1.190232</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span>  <span class="comment"># true c = 0.8 </span></span><br><span class="line">  X1.9 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n1 <span class="punctuation">,</span> <span class="number">1.812388</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span>  <span class="comment"># true c = 0.9 </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## ROC area ### </span></span><br><span class="line">  Results<span class="punctuation">[</span>j<span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> rcorr.cens<span class="punctuation">(</span>x<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>X0<span class="punctuation">,</span>X1.7<span class="punctuation">)</span><span class="punctuation">,</span> S<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span>n0<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span>n1<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> outx<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> </span><br><span class="line">  Results<span class="punctuation">[</span>j<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> rcorr.cens<span class="punctuation">(</span>x<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>X0<span class="punctuation">,</span>X1.8<span class="punctuation">)</span><span class="punctuation">,</span> S<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span>n0<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span>n1<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> outx<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> </span><br><span class="line">  Results<span class="punctuation">[</span>j<span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> rcorr.cens<span class="punctuation">(</span>x<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>X0<span class="punctuation">,</span>X1.9<span class="punctuation">)</span><span class="punctuation">,</span> S<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span>n0<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span>n1<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> outx<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> </span><br><span class="line"><span class="punctuation">&#125;</span> <span class="comment"># end simulation </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Count complete separation </span></span><br><span class="line">mean<span class="punctuation">(</span>Results<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="operator">==</span><span class="number">1</span><span class="punctuation">)</span> <span class="comment"># 6.2% </span></span><br><span class="line">mean<span class="punctuation">(</span>Results<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="operator">==</span><span class="number">1</span><span class="punctuation">)</span> <span class="comment"># 14.8% </span></span><br><span class="line">mean<span class="punctuation">(</span>Results<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="operator">==</span><span class="number">1</span><span class="punctuation">)</span> <span class="comment"># 35.4% </span></span><br><span class="line"><span class="comment">############################# </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Repeat with 100 events </span></span><br><span class="line"><span class="comment"># Simulation </span></span><br><span class="line">i <span class="operator">=</span> <span class="number">100000</span> </span><br><span class="line">Results100  <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span>nrow<span class="operator">=</span>i<span class="punctuation">,</span> ncol<span class="operator">=</span><span class="number">3</span><span class="punctuation">)</span> </span><br><span class="line">set.seed<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>j <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span>i<span class="punctuation">)</span> <span class="punctuation">&#123;</span> <span class="comment"># start simulation </span></span><br><span class="line">  n0 <span class="operator">&lt;-</span> 233 </span><br><span class="line">  n1 <span class="operator">&lt;-</span> 100 <span class="comment"># 0.3 event rate </span></span><br><span class="line">  X0 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n0 <span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span> </span><br><span class="line">  X1.7 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n1 <span class="punctuation">,</span> <span class="number">0.7416145</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span> </span><br><span class="line">  X1.8 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n1 <span class="punctuation">,</span> <span class="number">1.190232</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span> </span><br><span class="line">  X1.9 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n1 <span class="punctuation">,</span> <span class="number">1.812388</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment">## ROC area ### </span></span><br><span class="line">  Results100<span class="punctuation">[</span>j<span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> rcorr.cens<span class="punctuation">(</span>x<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>X0<span class="punctuation">,</span>X1.7<span class="punctuation">)</span><span class="punctuation">,</span> S<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span>n0<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span>n1<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> outx<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> </span><br><span class="line">  Results100<span class="punctuation">[</span>j<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> rcorr.cens<span class="punctuation">(</span>x<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>X0<span class="punctuation">,</span>X1.8<span class="punctuation">)</span><span class="punctuation">,</span> S<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span>n0<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span>n1<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> outx<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> </span><br><span class="line">  Results100<span class="punctuation">[</span>j<span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> rcorr.cens<span class="punctuation">(</span>x<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>X0<span class="punctuation">,</span>X1.9<span class="punctuation">)</span><span class="punctuation">,</span> S<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span>n0<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span>n1<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> outx<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span>   </span><br><span class="line"><span class="punctuation">&#125;</span> <span class="comment"># end simulation </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Same for 500 events ## </span></span><br><span class="line"><span class="comment"># Simulation </span></span><br><span class="line">i <span class="operator">=</span> <span class="number">100000</span> </span><br><span class="line">Results500  <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span>nrow<span class="operator">=</span>i<span class="punctuation">,</span> ncol<span class="operator">=</span><span class="number">3</span><span class="punctuation">)</span> </span><br><span class="line">set.seed<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span>j <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span>i<span class="punctuation">)</span> <span class="punctuation">&#123;</span> <span class="comment"># start simulation </span></span><br><span class="line">  n0 <span class="operator">&lt;-</span> 1167 </span><br><span class="line">  n1 <span class="operator">&lt;-</span> 500 <span class="comment"># 0.3 event rate </span></span><br><span class="line">  X0 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n0 <span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span> </span><br><span class="line">  X1.7 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n1 <span class="punctuation">,</span> <span class="number">0.7416145</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span> </span><br><span class="line">  X1.8 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n1 <span class="punctuation">,</span> <span class="number">1.190232</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span> </span><br><span class="line">  X1.9 <span class="operator">&lt;-</span> rnorm<span class="punctuation">(</span>n1 <span class="punctuation">,</span> <span class="number">1.812388</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment">## ROC area ### </span></span><br><span class="line">  Results500<span class="punctuation">[</span>j<span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> rcorr.cens<span class="punctuation">(</span>x<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>X0<span class="punctuation">,</span>X1.7<span class="punctuation">)</span><span class="punctuation">,</span> S<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span>n0<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span>n1<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> outx<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> </span><br><span class="line">  Results500<span class="punctuation">[</span>j<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> rcorr.cens<span class="punctuation">(</span>x<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>X0<span class="punctuation">,</span>X1.8<span class="punctuation">)</span><span class="punctuation">,</span> S<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span>n0<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span>n1<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> outx<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> </span><br><span class="line">  Results500<span class="punctuation">[</span>j<span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> rcorr.cens<span class="punctuation">(</span>x<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span>X0<span class="punctuation">,</span>X1.9<span class="punctuation">)</span><span class="punctuation">,</span> S<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span>n0<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span>n1<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> outx<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span>   </span><br><span class="line"><span class="punctuation">&#125;</span> <span class="comment"># end simulation </span></span><br><span class="line"><span class="comment"># summarize results </span></span><br><span class="line">describe<span class="punctuation">(</span>as.data.frame<span class="punctuation">(</span>Results<span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line">describe<span class="punctuation">(</span>as.data.frame<span class="punctuation">(</span>Results100<span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line">describe<span class="punctuation">(</span>as.data.frame<span class="punctuation">(</span>Results500<span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line"></span><br><span class="line">apply<span class="punctuation">(</span>Results<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span>mean<span class="punctuation">(</span>x<span class="operator">&lt;</span><span class="number">.5</span><span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line"><span class="comment"># [1] 0.15197 0.05001 0.00615</span></span><br><span class="line">apply<span class="punctuation">(</span>Results<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span>quantile<span class="punctuation">(</span>x<span class="punctuation">,</span> probs <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.025</span><span class="punctuation">,</span> <span class="number">0.975</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line"><span class="comment"># [,1]      [,2]      [,3]</span></span><br><span class="line"><span class="comment"># 2.5%  0.2857143 0.4285714 0.6190476</span></span><br><span class="line"><span class="comment"># 97.5% 1.0000000 1.0000000 1.0000000</span></span><br><span class="line">apply<span class="punctuation">(</span>Results100<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span>quantile<span class="punctuation">(</span>x<span class="punctuation">,</span> probs <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.025</span><span class="punctuation">,</span> <span class="number">0.975</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line"><span class="comment"># [,1]      [,2]      [,3]</span></span><br><span class="line"><span class="comment"># 2.5%  0.6382403 0.7466094 0.8628326</span></span><br><span class="line"><span class="comment"># 97.5% 0.7596567 0.8490987 0.9330912</span></span><br><span class="line">apply<span class="punctuation">(</span>Results500<span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span>quantile<span class="punctuation">(</span>x<span class="punctuation">,</span> probs <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.025</span><span class="punctuation">,</span> <span class="number">0.975</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line"><span class="comment"># [,1]      [,2]      [,3]</span></span><br><span class="line"><span class="comment"># 2.5%  0.6727266 0.7768638 0.8839314</span></span><br><span class="line"><span class="comment"># 97.5% 0.7266461 0.8225587 0.9152837</span></span><br><span class="line"><span class="comment">##################################### </span></span><br><span class="line"><span class="comment"># Plot results</span></span><br><span class="line">library<span class="punctuation">(</span>lattice<span class="punctuation">)</span>  </span><br><span class="line">Results.combi <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>Results<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> Results<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> Results<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">                   Results100<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> Results100<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> Results100<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                   Results500<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> Results500<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> Results500<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">)</span> </span><br><span class="line"></span><br><span class="line">Results.combi <span class="operator">&lt;-</span> as.data.frame<span class="punctuation">(</span>cbind<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">3</span><span class="operator">*</span> i<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">100</span><span class="punctuation">,</span> <span class="number">3</span><span class="operator">*</span> i<span class="punctuation">)</span><span class="punctuation">,</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">500</span><span class="punctuation">,</span> <span class="number">3</span><span class="operator">*</span> i<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span>  </span><br><span class="line">                                     <span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0.7</span><span class="punctuation">,</span> i<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0.8</span><span class="punctuation">,</span> i<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0.9</span><span class="punctuation">,</span> i<span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                                       <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0.7</span><span class="punctuation">,</span> i<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0.8</span><span class="punctuation">,</span> i<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0.9</span><span class="punctuation">,</span> i<span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                                       <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0.7</span><span class="punctuation">,</span> i<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0.8</span><span class="punctuation">,</span> i<span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">0.9</span><span class="punctuation">,</span> i<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> Results.combi<span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">dimnames</span><span class="punctuation">(</span>Results.combi<span class="punctuation">)</span><span class="punctuation">[[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Events&quot;</span><span class="punctuation">,</span> <span class="string">&quot;AUC&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Estimates&quot;</span><span class="punctuation">)</span> </span><br><span class="line"></span><br><span class="line">Results.combi<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span> <span class="operator">&lt;-</span>factor<span class="punctuation">(</span>Results.combi<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span>levels<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span><span class="number">100</span><span class="punctuation">,</span><span class="number">500</span><span class="punctuation">)</span><span class="punctuation">,</span>labels<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;3 events&quot;</span><span class="punctuation">,</span><span class="string">&quot;100 events&quot;</span><span class="punctuation">,</span><span class="string">&quot;500 events&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> </span><br><span class="line">Results.combi<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span> <span class="operator">&lt;-</span>factor<span class="punctuation">(</span>Results.combi<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span>levels<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.7</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">,</span> <span class="number">.9</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                           labels<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;C=0.7&quot;</span><span class="punctuation">,</span><span class="string">&quot;C=0.8&quot;</span><span class="punctuation">,</span><span class="string">&quot;C=0.9&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span>  </span><br><span class="line"></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> Results.combi<span class="punctuation">,</span>aes<span class="punctuation">(</span>Estimates<span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  geom_histogram<span class="punctuation">(</span>fill<span class="operator">=</span><span class="string">&quot;pink&quot;</span><span class="punctuation">,</span>color<span class="operator">=</span><span class="string">&quot;black&quot;</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  facet_wrap<span class="punctuation">(</span>Events<span class="operator">+</span>AUC<span class="operator">~</span>.<span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  scale_x_continuous<span class="punctuation">(</span>limits <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.25</span><span class="punctuation">,</span><span class="number">1.06</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  scale_y_continuous<span class="punctuation">(</span>expand <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  theme_bw<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">ggsave<span class="punctuation">(</span><span class="string">&quot;simulation.png&quot;</span><span class="punctuation">,</span>plot <span class="operator">=</span> last_plot<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span>width <span class="operator">=</span><span class="number">8</span><span class="punctuation">,</span>height <span class="operator">=</span> <span class="number">8</span><span class="punctuation">,</span>dpi <span class="operator">=</span> <span class="number">600</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/80/v2-a4a1edf28b1034a154223cecbf0b7396_1440w.webp" alt="img"></p>
<h2 id="启示"><a href="#启示" class="headerlink" title="启示"></a><strong>启示</strong></h2><ol>
<li><p>在没有足够样本量的情况下，独立验证是误导性的，应该在模型评估步骤中取消。最好是使用所有数据进行模型开发，并使用某种形式的交叉验证或重抽样来评估模型的平均预测性能。</p>
</li>
<li><p>基本上，我们应该接受预测方面的小规模研究是探索性质的，充其量只能展示新生物学见解的潜力，不能期望提供临床适用的测试、预测模型或分类器。基于小样本研究开发预测模型后，模型验证的结果往往并不理想。例如，Mammaprint是一种包含70个基因的分类器，最初在《自然》杂志表。其相对风险（RR）为18，其中78个样本用于模型开发，19个样本用于独立验证。然而，后来更大规模的验证研究显示，在295名妇女中其RR为5.1，而在6693名妇女的前瞻性试验中RR为2.4。因此，充分规模的验证研究对于提供新的预测模型、生物标志物和分类器在将研究从计算机转移到临床中所能期望的实际估计至关重要。</p>
</li>
<li><p>验证研究应至少有100个事件才有意义，并且最好是更多而不是更少。此外，如果我们试图评估性能，应提供置信区间以展示估计的不确定性，而不是专注于p值。在大数据中，具有大样本量的验证目标应该转向量化模型性能的异质性，而不是天真地寻求对平均性能的确认，这也可以在不进行数据拆分的情况下估计。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>临床预测模型系列</category>
      </categories>
      <tags>
        <tag>临床预测模型</tag>
      </tags>
  </entry>
  <entry>
    <title>朝着更好的临床预测模型：七个开发步骤和验证的ABCD原则</title>
    <url>/year/022148903.html</url>
    <content><![CDATA[<p>那么就以这篇推文跟2023说再见吧。2024，劝人学医TDLP持续与各位订阅者一起学习进步！</p>
<p>尽管今天分享的这篇文章发表于2014年，但是这篇文章对于临床预测模型的开发和评价还是有很大的指导意义。作者结合自己的工作经验，深入浅出地介绍了临床预测模型建立的7个步骤以及模型评价的ABCD原则，旨在引导后人朝着更好的临床预测模型迈进。</p>
<span id="more"></span>



<p><img src="https://pic4.zhimg.com/80/v2-fb8e502bb9ff4db143ced23d25d23deb_1440w.webp" alt="Steyerberg, Ewout W, and Yvonne Vergouwe. “Towards better clinical prediction models: seven steps for development and an ABCD for validation.” European heart journal vol. 35,29 (2014): 1925-31. doi:10.1093/eurheartj/ehu207"></p>
<h2 id="文献概览"><a href="#文献概览" class="headerlink" title="文献概览"></a><strong>文献概览</strong></h2><p>临床预测模型为个体患者提供了有关疾病存在（诊断）或未来疾病进展过程中事件发生的风险估计（预后）。尽管目前有很多文章介绍临床预测模型的开发及评价等方面的内容，但质量参差不齐。在该综述中，作者建议在<strong>开发预测模型时应考虑以下七个步骤：(1)研究问题的考虑和初始数据检查；(2)预测因子的编码；(3)模型规范；(4)模型估计；(5)模型性能评估；(6)模型的内部验证；(7)模型呈现</strong>。预测模型的有效性评价在理想的情况下应在独立的数据集中进行。作者提出了四个关键指标来评估模型的性能，包括：（1）<strong>总体校准度，或模型截距</strong>；（2）<strong>校准斜率</strong>；（3）<strong>具有一致性统计的区分度</strong>；（4）<strong>临床应用价值，使用决策曲线分析</strong>。作为应用，作者开发并验证了急性心肌梗死患者30天死亡率的预测模型。这说明了所提出的框架对于加强心血管研究中预测模型的方法严谨性和质量的有用性。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>疾病的存在预测（诊断）或疾病未来过程中事件的预测（预后）在当前个体化医学时代变得更加关键。随着影像学、生物标志物和“组学”研究的不断进步，涌现出许多新的诊断和预后预测因子。</p>
<p>临床预测模型能够整合多个预测因子，为我们提供了对这些因子在模型中相对影响的深入理解。例如，我们可能对炎症标志物如C-反应蛋白在急性冠状动脉综合症的临床过程和结果中的独立预后价值感兴趣。此外，临床预测模型还能为个体患者提供绝对风险的估计。在这里，我们特别关注这类模型的第二个作用，它们通常是通过回归分析技术来开发的。Logistic回归分析在预测二分类事件，例如30天死亡率，中应用最为广泛。而Cox回归在处理时间-事件数据（如长期死亡率）时则是最常见的方法。</p>
<p><img src="https://pic2.zhimg.com/80/v2-9a195dab29ec795c1b54151ba73aaad1_1440w.webp" alt="图源于网络"></p>
<p>需要注意的是，临床预测模型的严格开发和验证至关重要。尽管有大量的方法学文献和发表的指导文件，但大多数模型存在方法上的缺陷，或者至少在报告上存在不足之处。作者提出了一种系统的模型开发和验证方法，并以急性心肌梗死患者30天死亡率的预测为例进行了说明。作者比较了一个简单模型（仅包括年龄）与一个更为复杂模型（包括年龄和其他关键预测因子）的性能，这两个模型是在小型或大型数据集中开发的。</p>
<h2 id="病例研究：预测急性心肌梗死患者30天死亡率"><a href="#病例研究：预测急性心肌梗死患者30天死亡率" class="headerlink" title="病例研究：预测急性心肌梗死患者30天死亡率"></a><strong>病例研究：预测急性心肌梗死患者30天死亡率</strong></h2><p>作为说明，作者使用Gusto-I试验中40830名急性心肌梗死患者的队列。这项试验的数据已用于许多分析，包括开发30天死亡率的预测模型和各种方法学研究。</p>
<p>作者在美国登记的患者队列中开发模型(n&#x3D;23,034,1565例患者死亡，以及n&#x3D;259，20例死亡的一小部分患者)。作者在美国境外登记的患者队列(n&#x3D;17796,1286例死亡)中验证了模型的性能。第一个模型只包括年龄作为Logistic回归分析中的连续线性变量，而稍微复杂的模型包括年龄、Killip分级、收缩压和心率。这些分析的代码可在<a href="https://link.zhihu.com/?target=http://www.ClinicalPredictionModel.org">http://www.ClinicalPredictionModel.org</a>上找到。最初的Gusto-I模型基于40830名患者，包括14个预测因子。</p>
<h2 id="模型开发的七个步骤"><a href="#模型开发的七个步骤" class="headerlink" title="模型开发的七个步骤"></a><strong>模型开发的七个步骤</strong></h2><p>作者提出了用回归分析开发预测模型的七个逻辑上不同的步骤。作者提供了一个术语表，总结了与预测模型开发和验证相关的术语的定义和特征。</p>
<p><img src="https://pic3.zhimg.com/80/v2-1a1af181deba16336d4b24a5afd2b8ba_1440w.webp" alt="img"></p>
<h3 id="第一步：定义问题和数据检查"><a href="#第一步：定义问题和数据检查" class="headerlink" title="第一步：定义问题和数据检查"></a><strong>第一步：定义问题和数据检查</strong></h3><p><strong>Step 1: Problem definition and data inspection</strong><br>开发临床预测模型首先需要考虑的问题就是确定预测问题。要解决的问题包括：</p>
<p><strong>确切的研究问题是什么？</strong></p>
<p>在预测研究中，我们通常都感兴趣的是洞察什么因素可以预测终点，以及基于各种因素的组合提供终点绝对风险估计的问题。事实上，在开发Gusto-I模型时，标题提到了“预测因素……”，这表明我们关注的是预测因素预测30天死亡率的问题。然而，该分析也描述了多变量预测模型的开发，在该模型中，使用Logistic回归公式的多种因素的组合可以预测绝对风险。为了深入了解预测因素的重要性，预测因素对结局事件的影响通常以相对尺度表示，例如，比值比(OR)。例如，年龄越大，30天死亡率越高，反映在Gusto-I中每10年的OR为2.3，95%的可信区间为2.2-2.4。相比之下，风险预测以绝对值范围内的概率表示，范围在0到100%之间。例如，对于50岁和80岁的患者，30天死亡率的预测风险分别为2%和20%。不确定性可以用95%的可信区间来表示。这与相对效应有关，但当提供绝对风险预测时，这可能会迷惑临床医生或者患者。</p>
<p><strong>关于预测因素已知的情况是什么？</strong></p>
<p>文献综述和统计学家与临床研究人员之间的紧密互动对于在建模过程中融入主题知识非常重要。完整的GUSTO-I数据集规模异常庞大，因此在许多建模决策中可以可靠地借鉴数据中的发现。通过从GUSTO-I中提取的较小数据集进行的模拟显示，开发的预测模型是不稳定的，并产生过于极端的预测。</p>
<p><strong>如何挑选病人？</strong></p>
<p>用于模型开发的患者数据通常是出于不同目的而收集的。GUSTO-I试验旨在研究链激酶和组织型纤溶酶原激活剂的治疗效果。该试验的纳入标准相对广泛，这意味着Gusto-I患者可能对急性心肌梗死患者群体具有合理的代表性。作者认识到，当随机对照试验数据用于预后研究时，代表性通常是一个令人担忧的问题，但这可能会被数据的卓越质量所抵消。对于当前医疗实践中的风险预测，Gusto-I数据可能已经过时，因为试验是20多年前的。</p>
<p><strong>另一个问题是，我们应该如何在预后分析中处理任何治疗效果？</strong></p>
<p>治疗效果可能具有特殊的意义，对基线预后因素的调整在估计适用于个别患者的治疗效果方面有几个优势。如果重点放在绝对风险预测上，治疗效果往往被忽视，因为与预后因素的影响相比，治疗效果通常相对较小。在作者对GUSTO-I试验的分析中，作者研究预后的影响，而不考虑治疗。</p>
<p>对于诊断预测模型，这些模型应该在被怀疑患有特定疾病的受试者中开发。选择应该模拟临床环境，例如，我们可能考虑对于疑似患有阻塞性冠状动脉疾病的胸痛患者开发一个诊断预测模型，该模型用于估计阻塞性疾病的风险。</p>
<p><strong>预测因子是否被可靠而完全地测量？</strong></p>
<p>许多数据集在某些潜在预测因子的数值方面是不完整的。默认情况下，具有任何缺失值的患者被排除在统计分析之外（完全病例分析或可用病例分析）。这是低效的，因为其他预测因子的可用信息被丢失。为解决这个问题，我们可以填补缺失值的最佳估计值，利用数据集中变量之间的相关性（包括预测因子、终点和辅助变量，如日历时间和地点）。有各种统计方法可用于执行此类缺失值的插补。多重插补是一种多次填补缺失值的程序（通常至少五次），以适当地处理估计过程的随机性。我们认识到插补应该谨慎进行，但通常比完全病例分析更可取。</p>
<p>在GUSTO-I研究中，基线数据的收集是前瞻性的，因为它是一项随机对照试验，并且所有预测因子的定义都在试验方案中得到了仔细记录。这使作者对数据的质量感到自信。它还限制了缺失值的发生，这些值通过考虑预测因子变量之间的相关性而进行单次插补程序来填补。</p>
<p><strong>终点是感兴趣的嘛？</strong></p>
<p>通常更偏向于硬性终点，比如GUSTO-I中的30天死亡率，这也是试验的主要终点。另一个重要问题是终点的发生频率，这决定了有效样本量（而非患者总数）。GUSTO-I数据集中有2851例死亡病例，这使得可靠的预测建模成为可能，其中一个常见的经验法则是要求每个变量至少有10个事件（EPV）。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c31a654b609ea78a08c71a9f2f872f09_1440w.webp" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s?__biz=MzkzNzMxNjgxMA==&mid=2247485114&idx=1&sn=8782185c36f275a839139b35e0b8a2f6&chksm=c2901e1ff5e797090651eb8b570db0e711432855242735ed8f5660495fb68f7db598d0009fee&scene=21%23wechat_redirect">R与临床预测模型|临床预测模型中的样本量计算问题及pmsampsize实现过程</a></p>
<h3 id="第二步：预测因子编码"><a href="#第二步：预测因子编码" class="headerlink" title="第二步：预测因子编码"></a><strong>第二步：预测因子编码</strong></h3><p><strong>Step 2: Coding of predictors</strong><br>分类和连续的预测变量可以以不同的方式进行编码。例如，很少出现的类别可以与其他类别合并。在GUSTO-I中，梗死的位置可能被编码为前壁 vs. 其他，而不是前壁、下壁和其他，因为除前壁或下壁外的其他位置很少见（占患者的3%），并且这并没有改善模型拟合（P &#x3D; 0.30，用于改善 logistic 回归模型的似然比检验）。连续的预测变量通常可以在回归模型中建模为线性关系，至少作为一个起点。解释预测变量的相对效应需要注意测量尺度。例如，年龄的重要性在每十年为单位时更容易解释（OR：2.3，每十年增加一倍的几率），而在每年为单位时则较难解释（OR：1.09，每年增加9%的机率）。对于非线性关系的预测变量，如 J 形或 U 形，线性项显然不适用。这样的形状可以有效地使用受限制的三次样条或分数多项式进行建模。这些函数提供了灵活性，但只使用了少量额外的回归系数。作者强调，在模型开发阶段不应将连续性变量转换为分类变量（分类为低于或高于某个特定阈值），因为这会导致有价值的信息丧失。在稍后的阶段中，如果预测信息的损失有限，我们可以将一些预测因子分类处理。</p>
<h3 id="第三步：模型规范"><a href="#第三步：模型规范" class="headerlink" title="第三步：模型规范"></a><strong>第三步：模型规范</strong></h3><p><strong>Step 3: Model specification</strong></p>
<p>可以遵循各种策略来选择要包括在预测模型中的预测因子。逐步选择方法被广泛应用于预测因子筛选，但有许多缺点。在259例患者的小样本中，年龄和收缩压是有统计学意义的预测因子，而Killip分级(P&#x3D;0.31)和心率(P&#x3D;0.92)不是有统计学意义的预测因子。在整个GUSTO-I数据集中，样本量足够大，可以依靠统计分析来识别预测因素。为Gusto-I模型选择的所有14个预测因子P值都小于0.01。一个相关的问题是研究人员应该如何处理回归模型中的假设，例如一个预测因子的效果是相同的，而不考虑其他预测因子的值。在完整的Gusto-I数据集中，有一个这样的项被包括在预测模型中(年龄*Killip分级)。似乎Killip分级越高，对老年患者的预后影响就越小。对于时间-事件数据，Cox模型假设影响的比例，这可以用包括时间在内的交互作用项进行测试。我们注意到，对预测因子的重要性、模型中的假设以及适应性进行迭代循环的测试可能会产生一个数据拟合良好的模型。但是，这样的模型可能提供的预测并不适用于研究数据之外的新对象（即“过拟合”）。一个简单而稳健的模型可能并不完全适应数据，但在研究特定数据时应该优先考虑，而不是一个过于精细调整的模型。同样，预测因子的选择通常应考虑临床知识和先前的研究，而不仅仅依赖于统计选择方法。</p>
<h3 id="第四步：模型估计"><a href="#第四步：模型估计" class="headerlink" title="第四步：模型估计"></a><strong>第四步：模型估计</strong></h3><p><strong>Step 4: Model estimation</strong><br>一旦模型被确定，就需要估计回归系数。对于 logistic 回归和 Cox 回归模型，我们通常使用最大似然（ML）方法来估计系数。一些现代技术已经被开发出来，旨在限制模型对可用数据的过度拟合，例如统计收缩技术、惩罚最大似然估计和最小绝对收缩与选择算子（LASSO）。对于在259名患者中估计的模型，作者发现一个收缩因子为0.82。应该将回归系数乘以该值，以提供对新患者更可靠的预测。</p>
<h3 id="第五步：模型性能"><a href="#第五步：模型性能" class="headerlink" title="第五步：模型性能"></a><strong>第五步：模型性能</strong></h3><p><strong>Step 5: Model performance</strong><br>对于一个提出的模型，研究人员需要确定其性能。通常使用几种性能指标，包括用于模型校准和判别的指标。我们将讨论这些指标以及用于模型验证的临床实用性指标。</p>
<h3 id="第六步：模型有效性"><a href="#第六步：模型有效性" class="headerlink" title="第六步：模型有效性"></a><strong>第六步：模型有效性</strong></h3><p><strong>Step 6: Model validity</strong><br>区分内部有效性和外部有效性是很重要的。预测模型的内部有效性是指对数据来源的基础人群有效性(“再现性”)。内部验证可能特别涉及预测指标选择的稳定性和预测的质量。使用随机样本进行模型开发，其余患者用于验证(‘拆分队列验证’)是一种常见但不是最优的内部验证形式。较好的方法是交叉验证（ cross-validation）和重抽样（bootstrap resampling），这些方法中的样本都是从模型开发队列的样本中替换而来的。在259名患者的小样本中，重抽样的结果提示模型对新患者的辨别能力预计将从0.82降至0.78。在开发预测模型时，应始终尝试这种内部验证(表1和表2)。</p>
<p><img src="https://pic1.zhimg.com/80/v2-155b8a00741b558825e072c7fde8aa54_1440w.webp" alt="img"></p>
<p>外部验证通常被认为是对预测模型的一种比内部验证更强和更有效的性能检验，因为它涉及的是模型的可转移性（泛化性），而不是再现性。外部效度可以通过研究最近接受治疗(时间验证)、来自其他医院(地理验证)或在完全不同的环境中接受治疗的患者(强外部验证)来评估。</p>
<h3 id="第七步：模型呈现"><a href="#第七步：模型呈现" class="headerlink" title="第七步：模型呈现"></a><strong>第七步：模型呈现</strong></h3><p><strong>Step 7: Model presentation</strong><br>最后一步是如何呈现预测模型，使其最好地解决临床需求。可以使用回归公式，例如与Gusto-I模型一起发布的公式。为了便于模型的适用性，有许多替代方案，包括评分系统和诺模图。最近的一个趋势是将预测模型作为基于网络的计算器，或作为手机和平板电脑的应用程序。在未来，预测模型可能会很好地嵌入决策辅助工具和电子患者记录中，以支持临床决策。</p>
<h2 id="用于模型验证的ABCD原则"><a href="#用于模型验证的ABCD原则" class="headerlink" title="用于模型验证的ABCD原则"></a><strong>用于模型验证的ABCD原则</strong></h2><p>无论用什么方法来建立一个模型，模型有效性才是最重要的度量标准。作者在评估预测模型的有效性时提出了四个关键指标，与校准、区分和临床用途有关。通过研究在美国登记参加Gusto-I的259名或23 034名患者所开发的模型的外部有效性，并在来自美国以外的17796名Gusto-I患者中进行测试，作者说明了这些指标的意义。</p>
<h3 id="Alpha：大范围校准（calibration-in-the-large）"><a href="#Alpha：大范围校准（calibration-in-the-large）" class="headerlink" title="Alpha：大范围校准（calibration-in-the-large）"></a><strong>Alpha：大范围校准（calibration-in-the-large）</strong></h3><p>校正是指观察到的终点和预测之间的一致性。例如，如果我们预测患者在30天内死亡的风险为5%，那么在这样的预测下，观察到的比例应该是每100人中有5人死亡。可以用图形来很好地评估模型的校准能力-即校准图(图1)。在校准图中，Y轴上的观测值为0或1(死&#x2F;活)，而x轴上的预测值在0至100%之间。为了直观地显示观察值和预测值之间的一致性，可以使用平滑技术来很好地描述两者之间的相关性。我们还可以绘制具有类似预测风险的患者组的观察到的死亡比例，例如，通过预测的十分之一。考虑到这类群体与理想情况（预测值和观测值完全一致，即图1中的斜线）的偏差，使该图成为常用的Hosmer-Lemesow拟合优度检验的图形说明。然而，作者不建议将此测试用于评估模型的校准度。因为它不指明任何错误校准的方向，仅提供每组患者观察到的和预测的终点之间的差异的P值。这种分组是任意和不精确的，P值取决于错误校准的程度和样本大小的组合。相反，作者强调考克斯在1958提出的旧的重新校准的思想。完美预测应该在理想线上，用截距α(‘A’)&#x3D;0和斜率β(‘B’)&#x3D;1来描述。预测的对数比值被用作0&#x2F;1结局的预测因子，或对数风险比用于时间-事件数据。反之，不完美校准可以通过偏离这些理想值来表征。截距A与整体校准有关，它将所有预测风险的平均值与观察到的平均风险进行比较。因此，该参数表示系统预测过低或过高的程度。在模型开发时，回归模型的观察发病率和平均预测风险是相等的，对总体校准的评估是没有意义的。在外部验证中，经常发现大规模校准问题，例如，在多个种族群体中的Framingham模型，或NICE为英国开发的Framingham延伸模型。如果我们测试在美国以外的23 034名美国患者中开发的预测模型，我们注意到略高的死亡率(A&#x3D;0.07，P&#x3D;0.38；相当于非美国和美国的OR为EXP(0.07)&#x3D;1.07，如图1所示)。需要注意的是，如果Cox模型被用于外部验证，那么截距不能计算。在这种情况下，我们可以将某个时间点(例如5年或10年)的预测风险的平均值与Kaplan-Meier曲线的估计值进行比较。其他类型的模型，如威布尔（Weibull ）回归模型，也可用于评估生存模型的总体校准。</p>
<p><img src="https://pic4.zhimg.com/80/v2-f4a73acc786336ba2d37880573fd770b_1440w.webp" alt="图1在美国境外参加Gusto-I的17796名患者中应用的临床预测模型的校准曲线图。(A)大范围校准计算为Logistic回归模型截距，假设校准斜率等于1；(B)Logistic回归模型中的校准斜率，其中线性预测值是唯一的预测值；(C)C统计量表明区分度。三角形表示按相似预测风险分组的受试者的十分位数。图底部表示受试者"></p>
<h3 id="Beta：校准斜率（calibration-slope）"><a href="#Beta：校准斜率（calibration-slope）" class="headerlink" title="Beta：校准斜率（calibration slope）"></a><strong>Beta：校准斜率（calibration slope）</strong></h3><p>如果模型是在相对较小的数据集中开发的，则校准斜率B通常小于1。这样的发现反映出预测太过极端：低预测太低，高预测太高。对于基于259名患者的模型，17796名非美国患者的斜率为0.70，与内部验证时的预期一致(收缩系数0.82)。对于基于23034名患者的模型，B在通过交叉验证或重抽样的内部验证时接近1，在非美国患者的外部验证时接近1(斜率0.99，与图1的斜率1相比P&#x3D;0.55)。</p>
<h3 id="Concordance-statistic-discrimination（一致性统计：区分度）"><a href="#Concordance-statistic-discrimination（一致性统计：区分度）" class="headerlink" title="Concordance statistic: discrimination（一致性统计：区分度）"></a><strong>Concordance statistic: discrimination（一致性统计：区分度）</strong></h3><p>区分度指的是模型区分出现终点事件的病人(死亡)和没有出现终点事件的病人(活着)的能力。较好的判别模型与较差的判别模型相比在预测之间的差异更大。事实上，预测所有受试者的预测风险等于发病率的模型具有完美的校准能力，但由于它并不能区分患者，因此并不能带来实际的用处。显示为直方图的预测之间或预测风险的十分位之间存在广泛差异的验证图，表明模型有很好的区分能力(图1)。区分能力通常用一致性(C)统计量来量化。对于二分类终点，C统计量与受试者工作特征(ROC)曲线下的面积相同，ROC曲线展示预测模型对于预测终点事件的灵敏度和区分度。对于时间-事件终点，例如存活率，C的计算可能会受到不完全随访(删失)的量的影响。我们注意到，C统计量对校准中的系统误差不敏感，并考虑了在有和没有终点的一对患者中相当人为的分类情况。在Gusto-I中，C-统计量表明，在两个患者中，一个在30天内死亡，另一个存活，死亡的患者将具有比存活患者更高的预测风险。较复杂的预测模型的C-统计量超过0.8[内部和外部验证时分别为0.813(0.802-0.824)和0.812(0.800-0.824)]。这一性能比只包括年龄的模型要好得多(外部验证时为0.75)。在只有259名患者有进展的情况下，C-统计量为0.82，但内部验证为0.78，外部验证为0.80(0.79-0.82)。这说明较小的数据集的降低了外部验证的模型性能。</p>
<h3 id="Decision-curve-analysis（决策曲线分析）"><a href="#Decision-curve-analysis（决策曲线分析）" class="headerlink" title="Decision-curve analysis（决策曲线分析）"></a><strong>Decision-curve analysis（决策曲线分析）</strong></h3><p>校准度和区分度是反映预测模型性能的两个重要方面，并考虑预测风险的全部范围。如果预测模型旨在指导治疗决策，则需要一个分界点，将患者分为低风险(不需要接受治疗)或高风险(需要接受治疗)。这一分界点是一个决策门槛。在门槛处，受益的可能性，例如由于溶栓治疗而降低的死亡率，恰好平衡了伤害的可能性，例如出血风险和财务成本。例如，2%的阈值意味着未经治疗的患者死亡的情况相比于出血事件的并发症和不必要治疗的患者的费用而言，是98：2，即49倍。通常很难定义一个门槛，因为往往缺乏关于利益和损害的相对权重的经验证据。此外，一些患者可能准备承担比其他患者更高的风险以获得可能的临床获益。因此，建议在量化预测模型的临床有用性时考虑一系列阈值。一旦应用一个阈值来将患者分为低风险和高风险，敏感性和特异性通常被用作有效性的衡量标准。考虑到治疗的危害和益处，结合终点的发生率，找到这些之间的最佳平衡也是可能的。敏感度和特异度之和只能用作有用性的简单汇总指标，因为这样的总和忽略了真阳性(在敏感度中考虑)和假阳性(在1-特异度中考虑)的相对权重。最近提出的更适当的汇总措施包括净获益(Nb)。这一衡量标准与使用最优决策阈值对病人进行分类是一致的。损害和益处的相对权重被用来定义阈值，并被用来计算真-减去假阳性分类的加权和。对于Gusto-I，我们首先注意到7%的总30天死亡率意味着最大NB为7%。如果我们使用0%的阈值，则可以获得这一结果。所有患者都是tPA治疗的候选对象，因为我们认为治疗没有任何危害。如果我们意识到治疗会带来一些伤害，那么最佳的决定门槛是0.0%。我们发现，根据模型的风险预测进行治疗决策会比治疗每个人产生略高的NB。例如，在2%的阈值下，在17796名非美国患者中，我们有1225个真阳性分类(候选治疗，死亡)，但也有11192个假阳性分类(候选治疗，但存活)。Nb的计算公式为(1225-2&#x2F;98×11 192)&#x2F;17 796&#x3D;5.6%(图2)。这只比治疗ALL略好一点，因为1286人死亡，16510人总体存活，因此治疗ALL的人数为Nb&#x3D;(1286-2&#x2F;98×16 510)&#x2F;17 796&#x3D;5.3%。这一差值为0.3%。这意味着，对于我们应用预测模型的每1000名患者，在不增加假阳性率的情况下，识别出额外的三个真阳性。阈值越高，Nb越高，例如5%(每1000个额外的真阳性净值中有19个)。仅根据年龄，在2%的决策阈值(0.04%，图2)中几乎没有NB，而在仅基于259名患者(0.2%，图2)的模型中，NB实际上是不存在的。图2说明，使用比年龄更多的预后信息可以增加模型的临床实用性，并且样本量越大，模型的执行效果越好。目前有公开的网站提供决策曲线分析的文档和软件(<a href="https://link.zhihu.com/?target=http://www.ecisioncurveanalysis.org">http://www.ecisioncurveanalysis.org</a>)，同时考虑二分类和时间-事件端点事件。</p>
<p><img src="https://pic4.zhimg.com/80/v2-0ef8baa80f2981e74f52bd9d18dc858b_1440w.webp" alt="图2在美国以外的17796名参加Gusto-I的患者中应用的预测模型的决策曲线"></p>
]]></content>
      <categories>
        <category>临床预测模型系列</category>
      </categories>
      <tags>
        <tag>临床预测模型</tag>
      </tags>
  </entry>
  <entry>
    <title>R学习|基于ggplot2，使用金字塔图可视化临床研究中的不良事件（AE）</title>
    <url>/year/021842331.html</url>
    <content><![CDATA[<p>对于临床研究而言，疗效和安全性是大家最关心的问题。那么，如何在一个临床研究中将读者们最关心的问题有效的展示出来至关重要。这期我们选择临床研究中的不良事件（AE）。通常来讲，在绝大多数文章中作者一般会使用表格来呈现不同干预组参与者不同AE的构成比。</p>
<span id="more"></span>

<p><img src="E:\Project\blog\source_posts\640.png"></p>
<p>例如上面提到的文章，作者在表格中展示了不同治疗组参与者任何级别和3级及以上AE的构成比。</p>
<p><img src="E:\Project\blog\source_posts\641-1708501729496.png"></p>
<p>此外，作者也通过类似于金字塔图的形式来展示一些AE在不同组中的发生情况。</p>
<p><img src="E:\Project\blog\source_posts\642-1708501763541.png"></p>
<p>上图貌似是从Prism中绘制得到的。那么，如何用R来达到上面的效果呢，确切的来说，是通过ggplot2。</p>
<p>要实现上一目标，我们得将目光转向金字塔图。那什么是金字塔图？金字塔图又有什么作用呢？</p>
<p><strong>金字塔图是一种图形表达方式，其形状类似金字塔，从顶部开始逐渐向底部扩展。它通常用于展示层次关系、分层结构或者逐级递减的数据。金字塔图在商业、统计学、人口学和市场营销等领域中被广泛应用。</strong></p>
<p><strong>金字塔图的基本特征包括：</strong></p>
<ol>
<li><p>层次结构： 金字塔图的形状呈金字塔状，从上到下逐渐变宽，表示数据的逐级递减或者逐级分层。</p>
</li>
<li><p>比例表达： 金字塔图的每个层次都代表了不同的数值或者占比，并且可以通过宽度或高度的变化来表示相对的数量。</p>
</li>
</ol>
<p><strong>金字塔图的作用包括：</strong></p>
<ol>
<li><p>展示层次结构： 金字塔图适用于展示具有明显层次结构的数据，例如组织层级、人口金字塔等。</p>
</li>
<li><p>比较占比：通过金字塔图，可以清晰地看到每个层次的占比情况，便于比较不同级别或群体之间的相对大小。</p>
</li>
<li><p>传达逐渐减少的趋势：当数据呈现逐级递减的趋势时，金字塔图能够生动地表达这种递减关系。</p>
</li>
<li><p>人口金字塔：金字塔图在人口学中被广泛用于展示不同年龄层次和性别的人口分布，形成人口金字塔，用于分析人口结构和趋势。</p>
</li>
</ol>
<p>在R中，可以通过apyramid包来绘制金字塔图。相关内容有很多推送，不再赘述。小编选择使用ggplot2来实现金字塔图的可视化，是因为后者具有更强的可编辑性。</p>
<p>以下是小编使用ggplot2绘制的金字塔图，来展示上面提到的表格中不同治疗组任意级别AE的发生构成比。</p>
<p>需要注意的是，里面的数据为小编随意生成，并不是原始表格中的数据。但值得肯定的是，下图可以更加清晰的来展示AE。也推荐大家用在自己的文章中，提升一点儿逼格。</p>
<p><img src="E:\Project\blog\source_posts\643-1708501793904.png"></p>
<hr>
<p>下面我们看下具体是如何实现的吧。</p>
<h2 id="加载包"><a href="#加载包" class="headerlink" title="加载包"></a>加载包</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载包</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span><span class="comment">#可视化</span></span><br><span class="line">library<span class="punctuation">(</span>ggsci<span class="punctuation">)</span><span class="comment">#配色</span></span><br><span class="line">library<span class="punctuation">(</span>tidyverse<span class="punctuation">)</span><span class="comment">#数据操纵</span></span><br><span class="line">library<span class="punctuation">(</span>ggrepel<span class="punctuation">)</span><span class="comment">#文本注释</span></span><br></pre></td></tr></table></figure>



<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 读入数据</span></span><br><span class="line">data<span class="operator">&lt;-</span>read.delim<span class="punctuation">(</span><span class="string">&quot;pyramid.txt&quot;</span><span class="punctuation">,</span>header <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 数据处理-宽数据格式转变为长数据格式</span></span><br><span class="line">data<span class="operator">%&gt;%</span></span><br><span class="line">  pivot_longer<span class="punctuation">(</span>cols <span class="operator">=</span> <span class="number">2</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">               names_to <span class="operator">=</span> <span class="string">&quot;Arm&quot;</span><span class="punctuation">,</span></span><br><span class="line">               values_to <span class="operator">=</span> <span class="string">&quot;Count&quot;</span><span class="punctuation">)</span><span class="operator">-&gt;</span>data2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算不同干预组不同AE的构成比</span></span><br><span class="line">data2<span class="operator">%&gt;%</span></span><br><span class="line">  mutate<span class="punctuation">(</span>Percent<span class="operator">=</span></span><br><span class="line">           ifelse<span class="punctuation">(</span>Arm<span class="operator">==</span><span class="string">&quot;Osimertinib&quot;</span><span class="punctuation">,</span>Count<span class="operator">/</span><span class="number">337</span><span class="punctuation">,</span>Count<span class="operator">/</span><span class="number">343</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">-&gt;</span>data2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生标签，将构成比转换为百分数</span></span><br><span class="line">data2<span class="operator">%&gt;%</span></span><br><span class="line">  mutate<span class="punctuation">(</span>label<span class="operator">=</span>sprintf<span class="punctuation">(</span><span class="string">&quot;%.0f%%&quot;</span><span class="punctuation">,</span> Percent <span class="operator">*</span> <span class="number">100</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">         Count<span class="operator">=</span>ifelse<span class="punctuation">(</span>Arm<span class="operator">==</span><span class="string">&quot;Osimertinib&quot;</span><span class="punctuation">,</span>Count<span class="punctuation">,</span><span class="operator">-</span><span class="number">1</span><span class="operator">*</span>Count<span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">-&gt;</span>Label</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">ggplot<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x<span class="operator">=</span>reorder<span class="punctuation">(</span>AE<span class="punctuation">,</span>Count<span class="punctuation">)</span><span class="punctuation">,</span>y<span class="operator">=</span>Count<span class="punctuation">,</span>fill<span class="operator">=</span>Arm<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span><span class="comment">#绘制图层</span></span><br><span class="line">  geom_col<span class="punctuation">(</span>data <span class="operator">=</span> data2 <span class="operator">%&gt;%</span> filter<span class="punctuation">(</span>Arm <span class="operator">==</span> <span class="string">&quot;Osimertinib&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span>alpha<span class="operator">=</span><span class="number">0.8</span><span class="punctuation">)</span> <span class="operator">+</span><span class="comment">#奥希替尼组条形图</span></span><br><span class="line">  geom_col<span class="punctuation">(</span>data <span class="operator">=</span> data2 <span class="operator">%&gt;%</span> filter<span class="punctuation">(</span>Arm <span class="operator">==</span> <span class="string">&quot;Placebo&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="comment">#安慰剂组条形图，绘制到坐标轴左半部分</span></span><br><span class="line">                 mapping <span class="operator">=</span> aes<span class="punctuation">(</span>y <span class="operator">=</span>Count<span class="operator">*</span> <span class="punctuation">(</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span>alpha<span class="operator">=</span><span class="number">0.8</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  coord_flip<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">+</span><span class="comment">#坐标轴翻转</span></span><br><span class="line">  <span class="comment"># 设置坐标轴范围</span></span><br><span class="line">  scale_y_continuous<span class="punctuation">(</span>limits <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">250</span><span class="punctuation">,</span><span class="number">350</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                     breaks <span class="operator">=</span> seq<span class="punctuation">(</span><span class="operator">-</span><span class="number">250</span><span class="punctuation">,</span><span class="number">350</span><span class="punctuation">,</span><span class="number">100</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                     labels <span class="operator">=</span> <span class="built_in">abs</span><span class="punctuation">(</span>seq<span class="punctuation">(</span><span class="operator">-</span><span class="number">250</span><span class="punctuation">,</span><span class="number">350</span><span class="punctuation">,</span><span class="number">100</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  scale_fill_jco<span class="punctuation">(</span>name<span class="operator">=</span><span class="string">&quot;Treatment Arm&quot;</span><span class="punctuation">,</span><span class="comment">#设置主题及图例标题和标签</span></span><br><span class="line">                 labels<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Osimertinib (n=337)&quot;</span><span class="punctuation">,</span><span class="string">&quot;Placebo (n=343)&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>x<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span>y<span class="operator">=</span><span class="string">&quot;Count of patients with AE&quot;</span><span class="punctuation">,</span></span><br><span class="line">       caption <span class="operator">=</span> <span class="string">&quot;Most Common Investigator-Assessed Possibly Causally Related AEs Reported in More Than or Equal to 5% of Patients</span></span><br><span class="line"><span class="string">Treated With Osimertinib or Placebo, by Maximum CTCAE Grade&quot;</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  ggtitle<span class="punctuation">(</span><span class="string">&quot;Pyramid plot to visualize the AEs in clinical study&quot;</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  theme_classic<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span>axis.line.y <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        axis.ticks.y <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        axis.line.x <span class="operator">=</span> element_line<span class="punctuation">(</span>linewidth <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        axis.text <span class="operator">=</span> element_text<span class="punctuation">(</span>color <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span>face <span class="operator">=</span> <span class="string">&quot;bold.italic&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        plot.title <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">12</span><span class="punctuation">,</span>color <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                  face <span class="operator">=</span> <span class="string">&quot;bold.italic&quot;</span><span class="punctuation">,</span>hjust <span class="operator">=</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        plot.caption <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">8</span><span class="punctuation">,</span>color <span class="operator">=</span> <span class="string">&quot;grey&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                    face <span class="operator">=</span> <span class="string">&quot;italic&quot;</span><span class="punctuation">,</span>hjust <span class="operator">=</span><span class="number">0.5</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  geom_hline<span class="punctuation">(</span>yintercept <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span>linewidth<span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span><span class="operator">+</span><span class="comment">#添加辅助线</span></span><br><span class="line">  geom_text_repel<span class="punctuation">(</span>data <span class="operator">=</span> Label <span class="operator">%&gt;%</span> filter<span class="punctuation">(</span>Arm <span class="operator">==</span> <span class="string">&quot;Osimertinib&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="comment">#添加奥希替尼组AE构成比的文本注释</span></span><br><span class="line">                  aes<span class="punctuation">(</span>label <span class="operator">=</span> label<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                  force <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">                  nudge_y <span class="operator">=</span><span class="number">15</span><span class="punctuation">,</span></span><br><span class="line">                  direction <span class="operator">=</span> <span class="string">&quot;x&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  hjust <span class="operator">=</span> <span class="number">0</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_text_repel<span class="punctuation">(</span>data <span class="operator">=</span> Label <span class="operator">%&gt;%</span> filter<span class="punctuation">(</span>Arm <span class="operator">==</span> <span class="string">&quot;Placebo&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="comment">#安慰剂组注释</span></span><br><span class="line">                  aes<span class="punctuation">(</span>label <span class="operator">=</span> label<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                  force <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">                  nudge_y <span class="operator">=</span><span class="operator">-</span><span class="number">15</span><span class="punctuation">,</span></span><br><span class="line">                  direction <span class="operator">=</span> <span class="string">&quot;x&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  hjust <span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="E:\Project\blog\source_posts\644-1708501816184.png"></p>
<p>本次的分享就到这里了！</p>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>ggplot2</tag>
      </tags>
  </entry>
</search>
